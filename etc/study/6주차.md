
오늘은 B-tree에대해 발표해보겠습니다. 

오늘의 토픽은 B-Tree B+Tree 의 개념과 차이점 입니다. 


*B-Tree/ B+Tree* 모두 탐색 성능을 높이기 위해 균형있게 높이를 유지하는 blaanced tree의 일종입니다. 

두가지 모두 인덱스를 이루고 있는 자료구조의 일종입니다. 

B-Tree는 모든 leaf node 가 같은 level 로 유지되도록 자동으로 밸런스를 맞춰주며 하나의 노드에 많은 정보를 담습니다. 이렇게 하나의 노드에 여러 정보를 담게 되고, 여러 자식을 가질 수 있게 되면서 차수라는 개념 최대 M개의 자식을 가질 수 있는 B-Tree를 M차 B-Tree라고 불립니다. 

B+tree는 기존의 B-Tree와 데이터의 연결리스트로 구현된 색인구조로 **index 부분**과 **leaf 노드로 구성된 순차 데이터 부분**으로 이루어진다. 인덱스 부분의 key 값은 leaf에 있는 key 값을 직접 찾아가는데 사용합니다. 키값은 중복될수 있지만 리프노드까지 내려갸야 한다는 단점이 있습니다. 하지만 같은 레벨의 모든 키값들이 정렬되어 있고, 같은 레벨의 Sibiling node는 연결리스트 형태로 이어져 있습니다.


B-tree는 작은 블록 크기와 적은 데이터를 다루는 경우에 유용하며, B+tree는 대량의 데이터와 범위 검색이 자주 수행되는 경우에 적합합니다. 그이유는 [1] B-tree는 키와 데이터 모두 노드에 저장하지만 B+tree는 키만 저장하기에 더 많은 데이터를 저장할 수 있습니다. [2] B-tree는 리프 노드가 연결되어 있지 않고 B+tree는 모든 리프가 연결되어 있어 범위 검색을 빠르게 수행 할 수 있습니다. 
[3] B+tree 는 리프노드만 실제 데이터를 가지고 있기에 메모리에서 한번에 처리할 수 있는 레코드 수가 증가합니다. 반면 B-tree는 하나의 노드에 여러 자료를 배치하며 더효율적으로 데이터를 저장소에 담을 수 있습니다. 

----

먼저 B-tree를 설명해 보겠습니다. 

B-tree는  **탐색 성능을 높이기 위해 균형 있게 높이를 유지하는 Balanced Tree의 일종이며 .** 모든 leaf node가 같은 level로 유지되도록 자동으로 밸런스를 맞춰줍니다. 자식 node의 개수가 2개 이상이며, node 내의 key가 1개 이상일 수 있습니다. 

 node의 자식 수 중 최댓값을 K라고 하면, 해당 B-Tree를 **K차 B-Tree**라고도 합니다. 
 균형이진트리의 연속이라 Worst Case: O(logN)의 검색 성능을 보여줍니다. 

B-tree 의 조건은 6가지가 있습니다. 

**1. node의 key의 수가 k개라면, 자식 node의 수는 k+1개이다.** 
사진에서 노드의 키 개수가 2개이기 때문에 자식 노드의 수는 3개가 됩니다. 

**2. node의 key는 반드시 정렬된 상태여야 한다.** 
보시다 싶이 노드의 값들의 숫자가 모두 정렬되어 있습니다. 

**3. 자식 node들의 key는 현재 node의 key를 기준으로 크기 순으로 나뉘게 된다.** 
부모의 노드 기준으로 자식의 노드 크기 순서가 배열 된 것을 볼 수 있습니다. 
	ex. [1,3] 노드가 [5,7] 노드와 자리가 바뀐다면 적절하지 않은 예시라고 볼 수 있습니다. 

**4. root node는 항상 2개 이상의 자식 node를 갖는다. (root node가 leaf node인 경우 제외)** 

5. M차 B-Tree라면 루트 노드와 리프 노드를 제외하고 최소 M/2개 이상의 데이터를 가지고 있어야 한다.
 
1. 마지막 리프노드는  최대 M개의 서브 트리를 갖는다.

	
**7. 모든 leaf node들은 같은 level에 있어야 한다.**

[ 탐색 ]
https://www.cs.usfca.edu/~galles/visualization/BTree.html

B-Tree를 탐색하는 방법은 간단합니다.

찾고자 하는 값보다 더 큰 값이 있는 위치의 인덱스를 가진 자식 노드(없다면 데이터 수만큼)로 이동해줍니다.

만약 여기서 5를 찾기 위해선 어떻게 해야 할까요?

루트 노드부터 탐색해줍니다.

**2) node의 key를 순회하여 K가 존재하면 탐색을 종료한다.** 
**3) k가 존재하지 않는다면, 어떤 이웃한 두 key 사이에 K가 들어가는 경우 사이의 포인터를 통해 자식 node로 내려간다.** 

루트 노드의 6(0번째)이 5보다 더 크죠? 0번째 자식 노드로 이동합니다. 0번째 자식 노드 2와 4 중에서 더 큰 값이 없으므로 2번째(데이터 수) 자식 노드로 이동해줍니다.

**4) leaf node까지 2~3을 반복한다.**


[key 삽입]

B-Tree는 균형을 유지해야 하기 때문에 key를 삽입하는 경우 트리의 변형이 발생한다. 

**1. 빈 트리인 경우 root node를 만들어 K를 삽입한다. root node가 가득 찬 경우 node를 분할하여 leaf node를 생성한다.** 
**2. K가 들어갈 leaf node를 검색 과정과 동일하게 탐색한다.** 
**3. 해당 leaf node에 자리가 남아있다면 정렬을 유지하도록 알맞은 위치에 삽입하고, leaf node가 꽉 차 있다면 K를 삽입한 후 해당 node를 분할한다.** 
**4. node가 분할되는 경우 node의 중앙값을 기준으로 분할한다. 중앙값은 부모 node로 합쳐지거나 새로운 node로 생성되고, 중앙값을 기준으로 왼쪽의 key는 왼쪽 자식, 오른쪽의 key는 오른쪽 자식으로 생성된다.**

삽입하기 위해선 2가지 경우가 있습니다.

1. 리프 노드가 M-2개 이하인 경우

이 경우엔 그냥 삽입하면 됩니다.

3차 B-Tree에 10을 삽입하는 경우