----
>  stop-the-world

GC을 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것
GC 작업을 완료한 이후에야 중단했던 작업을 다시 시작한다.

✔️ What is GC? 
자바 메모리 메니지먼트는 GC 에게 자동적으로 메모리를 할당해주어 `boilderplate code` 상용 코드가 아닌 코드들에 대한 개발을 더 빠르게 해주며 메모리 리크 등 다른 메모리 관련 문제들을 줄여준다. 

✔️ HOW DOES GC WORK WITHIN JVM?
GC 는 살아있는 오브젝트들을 트랙하고 나머지는 garbage 로 인식한다 (사용하지 않는 오브젝트들을 모은다고 생각하는 것의 반대이다.) 

==HEAP== - 다이나믹 (동적) 할당 메모리 
프로그램이 실행되고 있는 중에 JVM 에게 메니징 될수 있도록 OS 가 힙을 먼저 할당한다. 
* 모든 객체가 OS 와의 `global synchronization (전역 동기화)`를 맺지 않아도 되기 때문에 오브젝트 생성이 빠르다. 할당은 메모리 배열의 일부를 요구하고 오프셋 포인터를 앞으로 이동하며 다음 할당은 오프셋에서 시작해서 배열의 다음 부분을 차지한다. 

![[Pasted image 20221219112745.png]]

	➡️what is offset pointer?
	==오프셋==
	: 메모리는 정수형/실수형 변수를 함께 저장하기에 ==변수형 마다 오프셋(offset) 을 다르게 설정하고== 포인터 변수를 선언할때 해당 변수형의 주소를 저장한다. 
	여기서 오프셋은 메모리의 간격을 의미한다. 

	![[Pasted image 20221219112631.png]]

	
* 더 이상 사용되지 않으면 가비지 수집기는 기본 메모리를 회수하고 ==개체 할당에 재사용한다.== 명시적인 삭제가 없고 OS에 메모리가 반환되지 않는 것을 보여준다. 

==모든 객체는 JVM 이 HEAP 영역에 할당한다.== 
* 클래스 개체
* 정적 변수 및 코드 
개체가 참조되는 동안은 JVM 은 살아있다고 간주되며 객체가 더 이상 참조 되지않으면 
가비지 컬렉터가 해당 객체를 제거하고 사용되지 않은 메모리를 회수 합니다. 






Java는 프로그램 코드에서 메모리를 명시적으로 지정하여 해제하지 않는다.
✔️ 명시적으로 해제하는 경우 `System.gc()` 호출 