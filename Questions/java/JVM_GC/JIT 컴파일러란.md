----
  
> JIT 컴파일러 위치? 

✔️ Execution Engine(실행 엔진)
: 런타임 데이터 영역에 ==할당된 바이트코드를 실행 / 바이트코드를 읽고 조각 별로 실행==

![[Pasted image 20221226113806.png]]

[참고]
.java 확장자로 소스 코드를 작성하면 ==JVM 이 이해 할 수 있는 코드로 컴파일(compile)==을 해주고 
컴파일이 완료 되면 JVM 이 해석 가능한 `byte code`로 작성된 `.class` 확장자 클래스가 생성된다. 
클래스 파일은 어플리케이션 동작할때 ==메모리에 적재되어 JVM 실행 엔진에 의해 수행==된다. 

-   Interpreter : 바이트 코드를 명령어 단위로 실행하여 한줄씩 수행. 단점 : 느리다.
-   JIT(Just in time) Compiler : Interpreter 보완; 네이티브 코드로 컴파일된 코드 캐시 보관하여 실행
-   Garbage Collector : 동적으로 할당된 메모리중 사용하지 않는 메모리 반환 - 자동 메모리 관리

>  JIT 컴파일러란 무엇이고, 이것은 왜 필요할까요?

✔️ JIT 컴파일러 
: 처음 자바는 Interpreter방식으로 모든 코드를 컴파일 하였고 그때문에 속도가 느리다는 평가를 받았다.
JIT(Just in Time) 컴파일러는 ==하드웨어의 발전으로 native 코드로 직접 실행하는 방식==으로` CPU + OS (기계)`가 직접 읽고 수행하는 방식이다.

-   네이티브 캐쉬에 한번 컴파일된 코드를 보관하기 때문에 같은 코드 반복시, 
     매번 기계어 코드를 새로 생성하는 방식이 아닌 이전에 만든 ==기계어를 재사용함으로써 속도를 빠르==게 했다.
-   운영체제에 맞게 byte 실행 코드를 한번에 변환하여 실행하여 이전 Java Interpreter방식보다 성능이 10-20배 증가했다고 한다.

> ⭐ Interpreter or JIT Compiler

무조건 JIT Comipler방식이 옳은건 아니다...
: 한번만 실행되는 코드라면 Interpreter!
메소드의 반복 수행이 일정 정도를 넘는다면 JIT Compiler!

	🤵🏻 Interpreter 이 그냥 커피라면 JIT는 TOP야

#### | 키워드

-   `컴파일러` : `.java` 확장자로 저장된 소스 코드를 ==JVM이 이해할 수 있는 코드==로 컴파일 한다. 
-   `인터프리터` : "Write once Run Anywhere"
	- 이식성이 높은 언어의 이유 
	- 플랫폼에 맞게 인터프리터가 바이트 코드를 실행한다. (Window, Mac, Linux)

	![[Pasted image 20221226133225.png]]
JVM 인터프리터는 ==런타임에 바이트 코드를 하나씩== 읽어드리는 방식으로 C, C++와 같이 미리 컴파일하여 기계어로 변경되는 언어에 비해 속도가 느리다. 
- `JIT Compiler`
	- ==자주 실행되는 바이트 코드 영역을 런타임 중에 기계어로 컴파일==해서 사용한다.  

#### | 꼬리질문

>  AOT 컴파일은 무엇일까요?

`Ahead Of Time` 컴파일러 
목표 시스템의 기계어와 무관하게 중간 언어 형태로 배포된 후 인터프리터나 JIT 컴파일러 등 기계어 변역을 통해
실행되는 중간 언어를 ==미리 목표 시스템의 기계어로 변역==하는 방식
JIT 가 런타임에 컴파일하기에 발생하는 성능 이슈가 생기지 않고 ==네이티브 성능을 낼 수 ==있다.

AOT 와 JIT 는 정반대의 개념이다! 

[[AOT vs. JIT]]

| 비교        | AOT                                                          | JIT                                                              |
| ----------- | ------------------------------------------------------------ | ---------------------------------------------------------------- |
| 컴파일 방식 | GraalVM 지원 빌드타임에 바이트 코드를 기계어로 정적 컴파일링 | Java HotspotVM 기본설정으로 런타임에 바이트 코드를 기계어로 변환 (동적 컴파일링)|
| 속도        | 빠르다                                                       | 첫 러닝타임에 모두 컴파일해야 하기에 느리다                      |
| 컴파일 타임 | Build Time                                                   | RunTime before display                                           |
| 사이즈      | JIT 의 half bundle size (optimized)                          | bundler size higher                                              |
|             | production                                                   | development                                                      |
| 에러 체크   | 빌드타임에 오류 확인이 가능하다                              | 애플리케이션이 화면에 띄울때 확인 가능하다.                                                                 |
 


>  C1 컴파일러와 C2 컴파일러는 무엇일까요?

Java Hotspot VM 안의 메이저 컴플라이어로 c1 과 c2 가 있다.
JVM 실행 될 때 JIT 컴파일러를 통해 핫코드를 간소화 시키는데 이 안에 C1 & C2 스레드가 있고 코드 효율성 최적화를 시킨다. 

⭐ 이 2개는 역할이 어떻게 다른가요?
C1 은 클라이언트 JIT 로 level 1-3 compilation tier(수행 빈도와 복잡도 레벨)을 담당하고
빠르고 가볍게 최적화된 바이트 코드 컴파일러를 실행한다. 
==런타임에 바이트 코드를 기계어로 변환하는 과정만 수행==

C2는 서버 JIT가 사용하는 스레드로 고도로 최적화된 바이트 코드 컴파일러로 level4(컴파일 + 기계어 캐싱) 를 수행하며 
C2는 더 오래걸리지만 가 더 최적화된 코드를 생성하며 필요 시에만 동작한다. 
==런타임에 바이트 코드를 기꼐어로 변환한 다음 캐시에 저장하는 과정을 수행==

*상세*
0: 인터프리트된 코드
1: 단순 C1 컴파일된 코드
2: 제한된 C1 컴파일된 코드
3: 전체 C1 컴파일된 코드
4: C2 컴파일된 코드

> 컴파일 과정에서 컴파일러가 최적화해주는 것들은 무엇무엇이 있을까요? (hotspot compiler optimization)
- 초기에 인터프리터 방식으로 바이트 코드로 변환되고 그 코드를 캐싱하여 같은 함수가 여러번 불릴 때 캐싱된 값 사용
- 컴파일 과정에서의 최적화
	- `b = obj1.equals(obj2);`
	- equals() 경우 오버라이드 되는데 인터프리터는 타입추론을 위해 동적 look up (dynamic look up)을 해야 한다. 동적 look up 은 런타임에 결정하는 것으로 매우 느리다. 인터프리터 방식으로 바이트 코드로 변환하여 ==jvm이 String 타입이라는 것을 안다면 동적 룩업을 하지 않는다==.  다른 가능성이라면 컴파일된 코드는 `코드캐시`에 올라가 자주 사용되는 코드는 동적으로 바뀌더라도 프로그램이 정지하지 않게 동작한다
	
✅ 인라이닝 : 호출된 메서드의 호출한 지점에 복사하는 것입니다.
	- 오버헤드 제거 가능 항목 :
		-    전달할 매개변수 세팅
		-   호출할 메서드를 정확하게 룩업
		-   새 호출 프레임에 맞는 런타임 자료 구조(지역 변수 및 평가 스택 등) 생성
		-   새 메서드로 제어권 이송
		-   호출부에 결과 반환 (결과값이 있는 경우)
✅ 루프 펼치기 
	- 루프 내부의 메서드 호출을 전부 인라이닝하면, ==컴파일러는 루프를 한번 순회할 때마다 비용과 크기==를 더 분명하게 알 수 있습니다.
	- 백브랜치(back branch)가 일어나면 그때마다 CPU는 유입된 명령어 파이프라인을 덤프하기 때문에 성능상 바람직하지 않습니다. 일반적으로 루프 바디가 짧을수록 백 브랜치 비용은 상대적으로 높기 때문에 다음의 기준으로 루프 펼치기 여부를 결정합니다.
✅ 탈출 분석
핫스팟은 어떤 메서드가 내부에서 수행한 작업을 그 메서드 경계 밖에서도 볼 수 있는지, 또는 부수 효과를 유발하지 않는지 범위 기반 분석을 통해서 판별합니다. 이러한 기법을 **탈출 분석**이라고 하며 메서드 내부에서 할당된 객체를 메서드 범위 밖에서 바라볼 수 있는지를 알아보는 용도로 사용됩니다.

일반적으로 세가지 유형으로 분류됩니다.

```java
typedef enum {
  // 객체가 메서드/스레드를 탈출하지 않고
  // 호출 인수로 전달되지 않으며,
  // 스칼라로 대체 가능하다.
  NoEscape = 1,

  // 객체가 메서드/스레드를 탈출하지 않지만
  // 호출 인수로 전달되거나 레퍼런스로 참조되며,
  // 호출 도중에는 탈출하지 않는다.
  ArgEscape = 2,

  // 객체가 메서드/스레드를 탈출한다.
  GlobalEscape = 3
}
```

✅ 락 생략/확장
✅ 단일형 디스패치
✅ 인트린직
✅  온-스택 치환

> 컴파일러 튜닝 
- 옵션 
	- `컴파일 튜닝`
		- 일정 기간 자주 사용하는 메소드를 JVM 옵션을 통해 설정한다. 
		- 코드캐시의 크기도 설정 가능다. 
			- `-XX:ReservedCodeCacheSize=N` : 코드 캐시의 최대 크기 지정
			- ` -XX:InitialCodeCacheSize=N` : 초기 코드 캐시의 크기 지정 
	- 컴파일 임계치 
		* 많이 사용 되는 메서드 컴파일하는데 그의 기준
		- method entry counter + back-edge loop counter
		 -   메서드가 호출된 횟수, 메소드 내의 루프가 있다면 루프를 빠져 나오기까지 돈 횟수 두 개를 기반으로 측정한다.
		-   두 카운터의 합계를 확인하고 메소드가 컴파일될 자격이 있는지 결정한다.
		-   자격이 있다면 컴파일되기 위해 큐에서 대기한다.
		-   큐에 있는 메서드들은 컴파일 스레드에 의해 컴파일된다.
			- `OSR : On - Stack Replacement` : 스택상 컴파일된 버전을 바로 실행하는 것 
			- `-XX:CompileThreshold=N` : 컴파일 임계치 지정 (클라이언트 디폴트 1,500/ 서버 디폴트 : 10,000)



https://blog.jdriven.com/2019/11/hotspot-jvm-optimizations/

#### | 검색 키워드

-   `JVM 컴파일러 최적화`
-   `hotspot compiler optimization`

#### | 내용

-   `+연산을 StringBuilder로 변환해주기`
-   `반복문 펼쳐주기`
-   `탈출분석`
-   `인라이닝`
-   `Etc...`

💡 컴파일러가 최적화해주는 것들이 정말 많습니다. 잘 찾아보세요.


![[Pasted image 20221226131057.png]]

[참고자료]
https://junhyunny.github.io/information/java/jvm-execution-engine/
JIT vs. AOT 
https://shirohoo.github.io/backend/java/2022-07-16-aot-vs-jit-in-java/
https://www.cesarsotovalero.net/blog/aot-vs-jit-compilation-in-java.html
http://daplus.net/angular-angular%EC%9D%98-jit-just-in-time-vs-aot-ahead-of-time-%EC%BB%B4%ED%8C%8C%EC%9D%BC/


https://heewon26.tistory.com/207
https://kotlinworld.com/307 - [JVM 의 JIT 컴파일이란? C1, C2를 이용한 최적화]
https://junuuu.tistory.com/126?category=989459
https://azderica.github.io/til/docs/java/optimizing-java/ch10/ - [JIT 최적화 기법]