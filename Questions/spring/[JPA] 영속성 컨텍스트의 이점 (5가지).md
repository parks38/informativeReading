----

#### | 영속성 컨텍스트 (persistence context)
: Entity 를 영구적으로 저장하는 환경 

`영속성 컨텍스트는 Entity Manager 를 생성할 때 함께 만들어지고`
`EntityManager를 통해 접근하고 관리가 가능하다 `

[특징]
엔티티를 식별자 값 (id)으로 구분하기에 ==영속상태에는 식별자 값이 존재해야 하며 영속성 컨텍스트에 엔티티를 저장하면 트랜잭션을 커밋하는 순간 데이터베이스에 반영==합니다. 

> 생명주기 

* 비영속 (new/transient)
	* 엔티티를 생성했지만 아직 영속성 컨텍스트에 저장하지 않은 상태 
* 영속(managed)
	* 엔티티 매니저를 통해 엔티티를 ==영속성 컨텍스트에 저장==한 상태 `em.persist()`
	* 영속성 컨텍스트에 의해 관리되며 ==아직 DB 저장되지 않음== 
* 준영속(detached)
	* 영속성 컨텍스트에 저장되었다가 분리 `em.detach()`
	* 영속성 컨텍스트가 영속 상태의 엔티티를 더이상 관리하지 않음. 
* 삭제(removed)
	* 엔티티를 영속성 컨텍스트와 DB 에서 삭제 `em.remove()`

[영속성 컨텍스트와 데이터 베이스]
`em.flush()`
트랜잭션 커밋 시 PC 에 저장된 내용을 ==DB에 자동 반영==(동기화) 한다. 

* 플러시 하는 방법
	* `em.flush()` 직접 호출
	* 트랜잭션 커밋시 플러시가 자동 호출
	* JPQL 쿼리 실행시 플러시 자동 호출 
* 옵션
	* `FlushModeType.AUTO` : 커밋이나 쿼리를 실행할때 플러시 (기본값)
	*  `FlushModeType.COMMIT` : 커밋할때만 플러시

#### | 영속성 컨텍스트의 이점 
[1] 1차 캐시 
[2] 동일성 보장
[3] 쓰기 지연 (Transaction write-behind)
[4] 변경 감지 (dirty checking)
[5] 지연 로딩 (lazy)

> 1차 캐시 

영속성 컨텍스트 내부에 Map 형태로 존재하여 ==조회== 가능하며 ==1차 캐시에 없으면 DB에서 조회해서 1차 캐시에 올려 놓는다== 
단 @Id 선언한 필드만 DB 기본 키와 매핑하여 조회 가능하다. 

JPA 는 1차 캐스를 통해 ==반복 가능한 읽기 (REPEATABLE READ) 등급의 트랜잭션 격리 수준==을 데이터베이스가 아닌 애프리케이션 차원에서 제공한다는 장점이 있다. 

![[Pasted image 20221130092145.png]]

 *참고*
 <u>1차 캐시 & 2차 캐시</u>
 네트워크를 통해 DB접근하는 것의 시간 비용은 서버 내부 메모리에 접근하는 것보다 비싸다. 그러므로 조회한 데이터를 메모리에 캐싱해두고 DB 접속 횟수를 줄이며 성능 개선이 가능하다. 

==1차 캐시==에서는 `객체 동일성` 을 보장하며 일반적으론 트랜잭션 시작부터 종료까지 유효하다. 
==2차 캐시==는 애플리케이션의 범위의 캐시로 (공유 캐시) 애플리케이션이 종료 될때까지 유효하다. 
`동시성`을 극대화 하기 위해 `캐시 한 객체를 직접 반환하지 않고 복사본을 만들어 반환`하여 동시성 문제를 해결한다. => 영속성 컨텍스트가 다르면 객체 동일성을 보장하지 않는다. 

> 동일성 보장 

```java
Member a = em.find(Member.class, "meber1");
Member b = em.find(Member.class, "meber1");

System.out.println(a == b);
```

JPA 는 `em.find(Member.class, "member1")` 를 반복해서 호출해도 
영속성 컨텍스트는 1차 캐시에 인스턴스를 반환한다. 
==영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다 

#동일성 이란? (identity)
실제 인스턴스가 같다. 따라서 참조 값을 비교하는 `==` 비교의 값이 같다. 

#동등성 이란? (equality)
실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같다. 자바에서 동등성 비교는 `equals()` 메소드로 구현해야 한다. 

> 쓰기 지연 (transaction write-behind)

`Entity Manager` 은 트랜잭션을 커밋하기 직전까지 DB 에 엔티티를 저장하지 않고 내부 쿼리 저장소 `쓰기지연 SQL 저장소`에 `insert SQL` 을 차곡차곡 모아둔다. 그리고 트랜잭션 커밋시 DB 로 보내진다. 

![[Pasted image 20221130110755.png]]

*[참고]*
-  트랜잭션을 지원하는 쓰기 지연 가능 이유?
	- 등록 쿼리를 그때그때 DB 에 전달해도 트랜잭션을 커밋하지 않으면 `쓰기지연 SQL 저장소`에 모아두는 것처럼 모두 롤백되고 의미가 없다. 
	- 커밋 직전에 DB 에 SQL 을 전달하기만 하면 된다. 


> 변경 감지 (dirty checking)

JPA 는 엔티티 영속성 컨텍스트를 보관할때 최초 상태를 복사 (`스냅샷`)하여 저장한다. 
그리고 플러시 시점에서 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다. 
==변경감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티만 적용된다.== 

[순서]
1. 트랜잭션 커밋하면 엔티티 매니저 내부에서 먼저 `flush()` 가 호출
2. 엔티티와 스냅샷을 비교해 변경된것을 찾는다. 
3. 변경이 있으면 수정 쿼리를 생성해 쓰기지연 SQL 에 보낸다. 
4. 쓰기지연 저장소의 SQL 을 DB에 보낸다. 
5. DB 트랜잭션을 커밋한다. 

 *[참고]*
 SQL 의 수정 쿼리의 문제점을 보안하기 위한 대책
  => 하나를 변경하려고 다수를 변경하다가는 문제가 생길수 있으며, 하나씩 수정쿼리를 만들면 쿼리가 너무 많아진다. 
 - 문제점
	 - 수정 쿼리가 많아지며 비즈니스 로직을 분석하기 위해 SQL 을 계속 확인해야 하며 직접적이든 간접적이든 비즈니즈 로직이 SQL 에 의존한다. 
 
> 지연 로딩 (lazy loading)

* 엔티티 조회 방법
	* `즉시로딩`
		* 엔티티를 조회할때 연관 엔티티도 조회
		* `@ManyToOne(fetch = fetchType.EAGER)`
		* JPA 구현체는 즉시 로딩을 최적화 하기 위해 조인 쿼리 사용 
	* `지연로딩`
		* 연관된 엔티티를 실제 사용할때 조회 
		* `@ManyToOne(fetch = fetchType.LAZY)`
		* 연관 엔티티를 프록시로 조회하여 실제 사용할때 초기화하며 데이터 베이스 조회

