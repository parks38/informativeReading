----
#### | 예상 답변 
JPA 의 save 는 두가지 방법으로 동작한다. 
[1] 새로운 객체(`최초`)를 저장하는 경우에는 ==persist()==를 이용하고 
[2] 준영속 상태 (detached)의 Entity를 영속화 시키는 경우 ==merge()==를 이용한다. 

persist()를 이용하면 insert() 쿼리 동작을 바로 실행한다. 

[용어 정리] 
* Deatached (준영속 상태) : 한번이라도 영속화 되었지만 현재는 영속화 되지 않은 상태인 Entity를 의미

[주요 포인트]
persist 와 merge의 동작 실행 차이점. 

#### | 상세 내용 

Save() 동작 방식 개발하던 도중에 오류에 부딪혔다. Entity 생성 시점에 대한 JPA 동작에 대한 이해가 부족하여 저장 프로시저를 올바르게 적용하였으나 해당 Enity에 적용이 되지 않은 문제가 발생하였다. 처음에는 저장 프로시저를 적용하는 단계에서 발생한 문제인가 하였으나 열심히 찾아본 끝에 JPA 에서 .save() 동작 방식에 대한 이해가 부족해서 였음을 알게 되었다.

##### | save 동작 실행 방법

Save() 는 두가지 방법으로 동작한다. 

첫번째는 ==새로운 객체를 저장하는 경우에는 persist() 를 통해 동작==된다. 새로운 entity를 영속성 컨텍스트 내에서 관리하고 싶을 때 사용된다. Persist()를 이용하면 바로 insert 쿼리 동작이 실행 된다.

두번째는 ==merge() 하는 방법==이 있다. 준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 병합을 사용하면 된다.

먼저 merge() 가 동작하는 방법을 설명해 보겠다. 
1. Merge() 실행 
2. 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티 조회 a. 1차 캐시에 적재되어 있지 않은 경우, DB에서 엔티티 조회하여 1차 캐시에 저장 
3. 조회한 영속성 컨텍스트에 값을 채워 넣는다.

이때, 주의해야하는 것이 있다. ==파라미터로 넘어오는 엔티티는 병합 후에도 준영속 상태로 남아 있다==. 이 의미는 준영속 상태인 entity와 영속 상태의 entity 는 서로 다른 인스턴스이며 참조하던 변수가 영속이되어 있는 엔티티를 참조하도록 변경해야 한다.

그리고 merge() 를 실행했을 경우 ==insert 는 select 이후의 시점에 발생== 된다.  
Save() 만 하고 select 를 하지 않았을 경우 아직 insert 되지 않았다고 생각하면 된다.

내가 마주했던 문제는 해당 문제였다. Select 이전에 준영속 상태의 entity 에 저장 프로시저를 실행 하려다 보니 값이 채워지지 않았던 것이다.

여기서 마지막으로, JPA 에 대한 이해를 돕기 위해 준영속 상태에 대한 설명도 간단히 해보겠다. 준영속 상태는 주로 영속성 컨텍스트가 종료되면서 준영속 상태가 됩니다. 비영속 상태와 가까우며 식별자는 가지고 있으나 영속성 컨텍스트가 제공하는 아래 기능들은 모두 사용할 수 없다.

-   1차 캐시
-   쓰기 지연
-   변경 감지
-   지연 로딩

평소에 save() 가 저장하는 것에만 집중을 했었는데 실제 동작하는 방법을 제대로 모르니 이런 오류가 발생될 수 있음에 신기하고 하나를 쓰더라도 제대로 동작하는 방법을 알아야 겠다는 생각이 들었다.

> 꼬리물기 

 - 준영속 상태란? 
 - 영속화 상세 단계? 
- 영속성 컨텍스트란 무엇인가? 
 - 영속성 컨텍스트 제공 하는 기능들에 대한 설명과 이점들
 - 왜 JPA 를 사용하는지
 - JPA 와 Mybatis 성능 비교 
 - ORM 이란? 
