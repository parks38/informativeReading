----
[Index]
- interface v.s AbstractClass 차이점
- interface 활용 1 : DI
- interface 활용 2 : ServiceImpl (interface) 패턴 사용 이유
	- OCP/ DIP 
	- AOP/ 결합도 

[개요]

대부분 프로젝트에서 Service들에 대해서 모두 인터페이스를 만들고 이에 대해 ServiceImpl(예) 식으로 따로 생성한 인터페이스를 구현한 모습을 볼 수 있습니다. 왜 이 방법을 활용하는 것인가? 

###### ➡️ Interface vs. Abstract

/ 이슬님 자료 [[인터페이스와 추상 클래스]]

답변 : 
추상 클래스는 `abstract` 키워드로 선언된 클래스이며 추상 메서드를 자식 클래스가 구체화 하여 그 기능을 확장하는 목적이 있습니다. 
인터페이스는 상속받은 서브 클래스에서 구현할 메서드들의 원형을 모두 알려주며, 클래스가 자신의 목적에 맞게 메서드를 구현하도록 하는 것입니다. 

[기능]
**추상클래스는 IS - A "~이다".** (단일 상속)
- 상속 관계를 쭉 타고 올라갔을때 같은 조상클래스를 상속하는데 기능까지 완변히 똑같은 기능이 필요한 경우(ex. attack, printInfo)

**인터페이스는 HAS - A "~을 할 수 있는".** (다중상속)
- 상속 관계를 쭉 타고 올라갔을때 다른 조상클래스를 상속하는데 같은 기능이 필요할 경우 인터페이스 사용 (ex. Swimable)

###### ➡️ 활용 1: 인터페이스 상속을 통한 안전한 기능 확장 

✅ [출처] 토비의 스프링 
- DI의 기능의 확장 
	- 기능 : 객체를 직접 생성하는 것이 아니라 외부에서 생성한 후 주입 시켜주는 방식 - 모듈간의 결합도가 낮아지고 유연성이 높아짐. 
	- 모든 기능을 클래스 하나안에 만들기 보다 내부 기능을 적절한 `책임` 과 `역할`에 따라 분리하고 `인터페이스`를 정의해 느슨하게 연결해 주고, DI 를 통해 유연하게 의존관계를 지정하도록 설계 
		- 세부적인 구현에 얽매이지 않고 유연한 의존관계를 맺으며 독립적으로 발전 => DI 역할 
		
- 스프링 DI 적용 
	- 사용할 오브젝트를 프로퍼티로 정의하고 xml 빈 설정을 이용해 주입 
	- di 의식한 설계 
		- 두개 이상의 의존 관계를 가지고 협력 
		- 적절한 책임에 따라 오브젝트 분리
		- 런타임 시, 의존 오브젝트를 다이나믹하게 연결해 유연한 확장의 목적을 염두하고 관계 설정 
		- 유연한 확장과 재사용 가능 설계 
- DI와 인터페이스 
	- DI 적용시 가능한 인터페이스 사용 필요 => 특별한 이유가 없다면 항상 인터페이스 사용 
	- 사용 이유: 
		- 1. 다형성 
			- 핵심 로직 이외에도 프록시, 데코레이터,어댑터, 테스터 대역 다양한 목적을 위해 인터페이스 통한 다형성 활용 
			- 상속 불가능한 final 클래스 이외에는 여러가지로 구현 확장 가능 => 템플렛 메소드
			- "인터페이스는 하나의 오브젝트가 여러 개를 구현할 수 있으므로 바라보는 창이 여러개"
				=> 각기 다른 관심과 목적을 가지고 어떤 오브젝트에 의존하고 있을 수 있다. 
				- 응집도 높은 작은 단위로 설계 되었어도 목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 적절히 분리 => `인터페이스 분리 원칙`
		- 2. 오브젝트의 기능이 발전하는 과정에서 다른 종류의 클라이언트 등장 
			- 인터페이스 여러개 만들기 보다 기존 인터페이스를 상속하여 확장 방법 가능 
			- `인터페이스 분리 원칙`
				- 자신의 고나심에 따른 접근 방식을 불필요한 간섭 없이 유지
				- 기존 클라이언트에 영향 주지 않은 채로 오브젝트의 기능을 확장하거나 수정 
			* ex. 
			![[Pasted image 20230320111047.png]]
			- 인터페이스를 사용해 di 관계를 만들어 sqlregistry 의 구현 클래스인 MySqlRegistry의 오브젝트가 제3의 클라이언트를 위한 인터페이스를 가질 수 이싿. 
			- MySqlRegistyr 기능이 확ㅈ아되며 새로운 클라이언트가 나타나 기존 SqlRegistry 확장 인터페이스 사용 필요 할 수 있다. 
			- 새롭게 추가할 기능에 대해서는 새로운 인터페이스를 정의하거나 기존 인터페이스를 확장하는 것이 바람직하다. 
			- ex.
			![[Pasted image 20230320111330.png]]
			-  SQL 업데이트 작업이 필요한 경우 UpdateableSqlRegistry 인터페이스를 통해 SQL 레지스트리 오브젝트에 접근하도록 하고 SQL 변경에 대한 요청은 웹이나 원격 호출 등의 다양한 방법을 통해 일어난다. 
				- `SQLAdmin Service -> UpdateableSqlRegustry -> SqlRegistry 접근 `
				- BaseSqlService 와 SqlAdminService 는 동일한 오브젝트를 의존하지만 관심과 필요에 따라 다른 인터페이스를 통한 접근 필요 
				- 인터페이스 추가 및 상속을 통한 확장 방식을 잘 활용하면 `유연한 확장 가능`
				- DI 와 객체지향 설계는 밀접한 관계가 있다. 

[공통된 기능 사용 여부]

###### ➡️ 활용 2: ServiceImpl 

> 왜 interface를 사용하여 미리 함수의 원형을 정의하고 그것을 impl한 class를 구체클래스로 구현을 하는가?
* service (interface)
* serviceImpl (class)

인터페이스를 규약해놓고 그것에 맞추어 여러 구현체를 구현하고, 다른 클래스에서 사용할 때 실제 구현체에 상관없이 개발할 수 있다는 OOP적 관점에서 사용한다. 
- 인터페이스라는 규약에 맞추어 개발되었기에 우리는 Impl 클래스의 실제적 구현을 상관하지 않고 구현할 수 있다는 것
- Controller 단에서 ServiceImpl 규약에 맞춰 잘 구현했을테니 인터페이스 함수를 가져다가 개발을 진행하며 그후 서비스 로직을 실제로 구현하는 것이다 => 구체 클래스에 의존하지 않고 개발 가능
	- service 구체 클래스 어떤 내부 로직으로 동작하는지 관심 가질 필요 없이 controller 클래스는 그냥 함ㅅ구를 가져다가 쓰면 됨. 

[키워드]
- 느슨한 결합
	- `nterface`를 사용함으로써, `service`에 의존하는 class는 더 이상 `service`의 구현에 의존하지 않게 된다. 이것이 `service`를 독립적으로 사용할 수 있게 해준다.
	
[interface 를 service 에 사용해야 하는 경우]
- 여러 방식의 구현 
- 제어의 역전 / IoC : 개발자가 직접 어하는 것이 아닌 외부에서 제어 및 관리는 해주는 것 
	- Spring IOC Container가 객체를 관리함으로써  DI(의존성 주입) , AOP(관점 지향 프로그래밍)이 가능

인터페이스 타입에 어떤 구현 객체를 대입하는지에 따라 실행결과가 달라지도록 만드는 기술이므로 기존 구현 객체(ServiceImpl1)와 **비즈니스 로직이 다른 기능을 추가해야할 경우** 다른 구현 객체(ServiceImpl2)를 만들어 사용하면 된다. 따라서 유지보수 측면에서 매우 좋다.

AOP와 트랜잭션은 서비스 인터페이스에서 처리한다.  
스프링에서 AOP를 구현할 때 JDK의 기본 프록시를 사용하는데, 이 프록시는 인터페이스 기반으로 동작하기 때문에 Service인터페이스를 만들어 사용한다.

**AOP란** 기존에 OOP에서 바라보던 관점을 다르게 하여 부가기능적은 측면에서 보았을 때 공통된 요소를 추출하자는 것입니다.
- AOP : 인프라, 부가 기능의 모둘화
	- 공통 기능 재사용 기법
	- 부가적인 기능을 분리하여 Aspect 라는 모듈로 설계하고 개발 


![[Pasted image 20230320182922.png]]





[참고]
https://velog.io/@kshired/Spring-Java-Interface-AbstractClass%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EA%B3%BC-ServiceImpl-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0
https://velog.io/@hsw0194/Spring-Boot%EC%97%90%EC%84%9C-interface%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C

https://velog.io/@hsw0194/Spring-Boot%EC%97%90%EC%84%9C-interface%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C

https://jung-story.tistory.com/129

https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-vs-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0

https://velog.io/@suhongkim98/%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B5%AC%ED%98%84-%EC%8B%9C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-spring-AOP

https://tecoble.techcourse.co.kr/post/2022-11-07-transaction-aop-fact-and-misconception/

