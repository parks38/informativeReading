----

> 답변 

인터페이스는 Spring에서 광범위하게 사용되며, 코드의 유지보수성과 확장성을 높여줍니다.
Spring 프레임워크는 인터페이스를 통해 다양한 기능과 장점을 제공합니다. 
1.  다형성(Polymorphism) 
	- 여러 개의 클래스를 하나의 타입으로 묶음 
	- 코드 유지 보수 및 확장성이 용이해짐
	- 의존성 주입(Dependency Injection)
    
2.  유연성과 확장성 
	- 다른 클래스가 동일한 메서드를 구현 가능 (다중상속)
	- 높은 유연성과 확장성을 제공
	- 클래스들 간의 의존성을 낮춰 코드 변경이 용이해짐 
    
3.  Mock 객체 생성 
	- 테스트 시 Mock 객체를 생성 가능
	- 코드 품질과 유지보수성을 높일 수 있음. 

[인터페이스를 사용하는 예시]

1.  DAO(Data Access Object) 인터페이스 
	- Spring에서는 DAO를 사용하여 데이터베이스와 연동
	- 데이터베이스와 직접적인 연결을 피하고, 더 좋은 유지보수성과 확장성 제공 
2.  Service 인터페이스 
	- 비즈니스 로직을 구현한 클래스를 노출시키지 않고, 추상화된 인터페이스 제공 
	- 유지보수성과 가독성을 높여주며 독립적으로 사용 가능 
	- oop 관점의 OCP 와 DIP 를 올바르게 사용
    
3.  AOP(Aspect Oriented Programming) 인터페이스 
	- 코드의 흐름을 수정하거나 기능을 추가 가능 
	-  JDK의 기본 프록시를 사용하는데 이는 인터페이스 기반으로 동작하기 때문에 Service인터페이스를 만들어 사용


[Index]
- interface v.s AbstractClass 차이점
- interface 활용 1 : DI
- interface 활용 2 : ServiceImpl (interface) 패턴 사용 이유
	- OCP/ DIP 
	- AOP/ 결합도 

[개요]
대부분 프로젝트에서 Service들에 대해서 모두 인터페이스를 만들고 이에 대해 ServiceImpl(예) 식으로 따로 생성한 인터페이스를 구현한 모습을 볼 수 있습니다. 왜 이 방법을 활용하는 것인가? 

###### ➡️ Interface vs. Abstract

/ 이슬님 자료 [[인터페이스와 추상 클래스]]

답변 : 
**추상클래스는 IS - A "~이다".** (단일 상속)
**인터페이스는 HAS - A "~을 할 수 있는".** (다중상속)

추상 클래스는 `abstract` 키워드로 선언된 클래스이며 추상 메서드를 자식 클래스가 구체화 하여 그 기능을 확장하는 목적이 있습니다. 
인터페이스는 상속받은 서브 클래스에서 구현할 메서드들의 원형을 모두 알려주며, 클래스가 자신의 목적에 맞게 메서드를 구현하도록 하는 것입니다. 

인터페이스는 구현 객체의 동작을 보장하고, 다중 상속을 지원하기 때문에 유연한 설계가 가능합니다. 반면 추상 클래스는 여러 개의 클래스에서 공통적인 특징을 뽑아내 추상화된 개념을 나타내는 경우 사용됩니다.

[인터페이스 사용 예시]
- 여러 방식의 구현 
- 제어의 역전 / IoC : 개발자가 직접 어하는 것이 아닌 외부에서 제어 및 관리는 해주는 것 
	- Spring IOC Container가 객체를 관리함으로써  DI(의존성 주입) , AOP(관점 지향 프로그래밍)이 가능

###### ➡️ 활용 1: DI - 인터페이스 상속을 통한 안전한 기능 확장 

✅DI  - [출처] 토비의 스프링 
- DI 기능 : 객체를 외부에서 생성한 후 주입을 통해 모듈간의 결합도가 낮아지고 유연성이 높아짐. 
	- 내부 기능을 적절한 `책임` 과 `역할`에 따라 분리하고 `인터페이스`를 정의해 느슨하게 연결해 주고, DI 를 통해 유연하게 의존관계를 지정하도록 설계 
		- 세부적인 구현에 얽매이지 않고 유연한 의존관계를 맺으며 독립적으로 발전 
		
- 스프링 DI 적용 
	- 사용할 오브젝트를 프로퍼티로 정의하고 xml 빈 설정 주입  
	- di 의식한 설계 
		- 두개 이상의 의존 관계를 가지고 협력 
		- 적절한 책임에 따라 오브젝트 분리
		- 런타임 시, 의존 오브젝트를 다이나믹하게 연결해 유연한 확장의 목적을 염두하고 관계 설정 
		- 유연한 확장과 재사용 가능 설계 
		
- DI와 인터페이스 
	- DI 적용시 가능한 인터페이스 사용 필요
	- 사용 이유: 
		- 1. 다형성 
			- 핵심 로직 이외에도 프록시, 데코레이터,어댑터, 테스터 대역 다양한 목적을 위해 `인터페이스 통한 다형성 활용` 
			- 상속 불가능한 final 클래스 이외에는 여러가지로 구현 확장 가능 
				=> 템플렛 메소드
			- "인터페이스는 하나의 오브젝트가 여러 개를 구현할 수 있으므로 바라보는 창이 여러개"
				=> 각기 다른 관심과 목적을 가지고 어떤 오브젝트에 의존하고 있을 수 있다. 
				- 응집도 높은 작은 단위로 설계 되었어도 목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 적절히 분리 => `인터페이스 분리 원칙`
				- 인터페이스 여러개 만들기 보다 기존 인터페이스를 상속하여 확장 방법 가능 
				- 자신의 고나심에 따른 접근 방식을 불필요한 간섭 없이 유지
				- 기존 클라이언트에 영향 주지 않은 채로 오브젝트의 기능을 확장하거나 수정 

###### ➡️ 활용 2: ServiceImpl 

> 왜 interface를 사용하여 미리 함수의 원형을 정의하고 그것을 impl한 class를 구체클래스로 구현을 하는가?

* service (interface)
* serviceImpl (class)

인터페이스를 규약해놓고 그것에 맞추어 여러 구현체를 구현하고, 다른 클래스에서 사용할 때 실제 구현체에 상관없이 개발할 수 있다는 OOP적 관점에서 사용한다. 
- 인터페이스라는 규약에 맞추어 개발 => Impl 클래스의 실제적 구현을 상관 없이 구현 
- 인터페이스 함수를 가져다가 개발을 진행하고 그후 서비스 로직을 실제로 구현하는 것이다 
	- 구체 클래스에 의존하지 않고 개발 가능
	- controller 클래스는 함수를 가져다가 쓰면 됨. 
	
- OOP 적 관점 / [[spring_boot serviceimpl oop 관점]]
	- ocp(개방 폐쇄의 원칙) : _소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다._
	- dip (의존관계 역전의 원칙) : _저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 하고 그 반대가 되면 안된다_
	- EX. 스프링을 사용하며 객체의 생성 제어를 IoC컨테이너에게 위임하고 컨트롤러에서 런타임 중에 어떤 자바빈을 주입할 지 인터페이스에게 위임하여 느슨한 결합도를 가지도록 함 
	
[interface 를 service 에 사용해야 하는 경우]
- 느슨한 결합
	- `Interface`를 사용함으로써, `service`에 의존하는 class는 더 이상 `service`의 구현에 의존하지 않게 된다. 
	   이것이 `service`를 독립적으로 사용할 수 있게 해준다.
	   
인터페이스 타입에 어떤 구현 객체를 대입하는지에 따라 실행결과가 달라지도록 만드는 기술이므로 기존 구현 객체(ServiceImpl1)와 **비즈니스 로직이 다른 기능을 추가해야할 경우** 다른 구현 객체(ServiceImpl2)를 만들어 사용하면 된다. 따라서 유지보수 측면에서 매우 좋다.

###### ➡️ 활용 3: AOP 
* AOP와 트랜잭션은 서비스 인터페이스에서 처리
- Spring AOP는 기본적으로 J2SE의 동적 프록시를 사용하여 AOP 프록시를 생성합니다. 동적 프록시는 인터페이스만 프록시할 수 있으므로 타깃 객체가 인터페이스를 구현해야 합니다[1](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html).
-   Spring AOP는 CGLIB 프록시도 사용할 수 있습니다. CGLIB 프록시는 클래스도 프록시할 수 있으므로 타깃 객체가 인터페이스를 구현하지 않아도 됩니다. 하지만 CGLIB 프록시는 성능상의 단점이 있고 final 메소드나 클래스에 적용할 수 없습니다[2](https://stackoverflow.com/questions/26158913/spring-aop-for-interface-and-for-annotated-methods-within-it)[1](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html).
-   Spring AOP는 인터페이스 기반의 설계와 개발을 권장하고 있으며, 인터페이스를 사용하면 코드의 결합도가 낮아지고 유연성이 높아집니다[3](https://goldengiant.tistory.com/151).

**AOP란** 기존에 OOP에서 바라보던 관점을 다르게 하여 부가기능적은 측면에서 보았을 때 공통된 요소를 추출하자는 것입니다.
- AOP : 인프라, 부가 기능의 모둘화
	- 공통 기능 재사용 기법
	- 부가적인 기능을 분리하여 Aspect 라는 모듈로 설계하고 개발 

> Spring의 AOP 프록시 구현 (jdk 동적 프록시/ CGLib 프록시)

 Spring은 프록시 타깃 객체에 인터페이스가 있다면 그 인터페이스를 구현한 JDK 다이내믹 프록시 방식으로 객체를 생성하고, 인터페이스가 없다면 CGLib을 이용한 클래스 프록시를 만든다.

1.  인터페이스를 구현하고 있는지 확인함
2.  인터페이스를 구현하고 있으면 JDK 다이내믹 프록시 방식으로 객체를 생성
3.  인터페이스를 구현하지 않으면 GCLib 방식으로 객체를 생성

하지만 JDK 동적 프록시 방식은 다음과 같은 2가지 한계점을 가지고 있다.

-   프록시를 적용하기 위해서 반드시 인터페이스를 생성해야 함
-   구체 클래스로는 빈을 주입받을 수 없고, 반드시 인터페이스로만 주입받아야 함



![[Pasted image 20230320182922.png]]





[참고]
https://velog.io/@kshired/Spring-Java-Interface-AbstractClass%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EA%B3%BC-ServiceImpl-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0
https://velog.io/@hsw0194/Spring-Boot%EC%97%90%EC%84%9C-interface%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C

https://velog.io/@hsw0194/Spring-Boot%EC%97%90%EC%84%9C-interface%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C

https://jung-story.tistory.com/129

https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-vs-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0

https://velog.io/@suhongkim98/%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B5%AC%ED%98%84-%EC%8B%9C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-spring-AOP

https://tecoble.techcourse.co.kr/post/2022-11-07-transaction-aop-fact-and-misconception/

[프록시 구현]
https://mangkyu.tistory.com/175
