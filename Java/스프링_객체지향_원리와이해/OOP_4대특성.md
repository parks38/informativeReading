### [객체 지향 4 대 특성]
* 캡슐화 : Encapsulation - 정보 은닉 (information hiding)
   - private
   - [default]
   - protected
   - public
   - CallByReference / CallByValue
* 상속 : extends - 재사용
  - 상위 클래스 특성을 재사용
  - 상위 클랫의 특성을 확장
  - 상속은 is a kind of 관계를 만족한다
  - implements interface
  - extends UpperClass
  - Promotion/Casting
* 추상화 : abstraction - 모델링
* 다형성 : Polymorphism - 사용자 편의
  - @Overriding
  - @Overloading 
 
 
### [자바가 확장한 객체 지향]
* 추상 메서드 : 선언부는 있는데 구현부가 없는 메서드
* 추상 클래스 : 추상 메서드가 단 하나라도 있는 클래스 
  - 인스턴스, 즉 객체를 만들수 없다. new 사용 불가능
  - 하위 클래스에게 메서드 구현 강제 -> Overriding
  - 추상 메서드 포함 클래스는 반드시 추상 클래스!!

* 생성자
  - 객체 생성자 메서드 : 번환값 없고 클래스명과 같은 이름의 메서드 <br>
    -> 자바에서는 자동으로 인자가 없는 기본 생성자 생성 <br>
    -> 인자가 있는 생성자를 하나라도 만들면 기본 생성자 생성 X <br> 

* static 블록
   - 객체 맴버는 클래스가 static 에 자리 잡은 후에 객체 새엉자를 통해 힙에 생성
   - static 블록 실행시 해당 클래스의 갹체는 하나도 존재하짇않기 때문에 static 블록에서 객체 멤버가 접근할수 없음. 
   - 클래스 처음 사용될때 : (단 한번만 실행0
     - 클래스의 정적 속성을 사용할때
     - 클래스의 정적 메서드를 사용
     - 클래스의 인스턴스를 최초로 생성 
   -스태틱 영역 = 메모리 : 메모리는 최대한 늦게 적재하고 최대한 빨리 반환하는 것이 정석
   - Junit @BeforeClass

* final 키워드
   - 클래스 : 상속을 허락하지 않는다. 
   - 메서드 : 오버라이딩 금지 
   - 변수 : 변경 불가능한 상수 

* instanceof 연산자
   - 인스턴스 => 클래스 통해 만들어진 객체
   - 클래스의 인스턴스인지 묻는 연산자
   - 객체_참조-변수 instanceof 클래스명 
   - 객체 지향 설계 LSP 을 어기는 코드로 나타나는 연산자 (주의 필요!)
   - 상속 && interface 모두 구현 가능

* package 키워드
   - 네임스페이스를 만들어주는 역할

* interface 키워드 & implements 키워드
   - interface -> public 추상 메서드와 정적 상수만 가질수 있음.

* this 키워드
   - 지역 변수에 저장되어 있는 값이 아닌 객체 변수에 저장된 값을 사용하고 싶은데 이름이 같을 때 this.var 라고 하면 객체 변수 var 에 지정한 값을 사용
   - 지역 변수와 속성(객체 변수, 정적 변수) 이름이 같으면 지역 변수가 우선
   - 갹체 변수와 이름이 같은 지역 변수가 있는 경우 객체 변수를 이용하려면 this 사용
   - 정적 변수와 이름이 같은 지역변수가 있는 경우, 정적 변수를 이용하려면 클래스명을 접두사로 사용 

* super
   - 바로 위 상위 클래스의 인스턴스 혹은 인스턴스 메서드를 지정

* TIP!
   - 객체명.객체메서드명() -> 클래스명.객체메서드명()  으로 JVM 인식
      - 객체 맴버 메서드는 객체별로 달라지지 않기 때문에 (속성값만 다를 뿐) 메모리 효율성을 위해 멤버 메서드를 스태틱 영역에 단 한개만 보유.
      - 호출할때 객체 자신을 나타내는 this 객체 참조 변수 넘김
