-----
[Question: 인덱스 사용하는 이유와 ]

인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
*  데이터베이스의 index는 책의 색인과 같다
* 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 도움 

![[Pasted image 20230320185023.png]]

* 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능이 함께 향상
	* 연산을 수행하려면 해당 대상을 조회
	* 전체를 탐색하는 Full Scan
		* 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어짐 

[사용 하는 이유]
① 조건 검색 WHERE 절의 효율성
 **인덱스 테이블 스캔(Index Table Scan) 시 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 해당 조건(WHERE)에 맞는 데이터들을 빠르게 찾아낼 수 있는 것**

**② 정렬 ORDER BY 절의 효율성**
인덱스를 사용하면 ORDER BY에 의한 정렬(Sort) 과정을 피할 수가 있다. ORDER BY는 굉장히 부하가 많이 걸리는 작업이다. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면 *디스크 I/O도 추가적으로 발생되기 때문이다. 하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 된다. 왜? 이미 정렬이 되어 있기 때문에 가져오기만 하면 되기 때문이다.

 **③ MIN, MAX의 효율적인 처리가 가능하다**
데이터가 정렬되어 있기에 얻을 수 있는 장점이다. MIN값과 MAX값을 레코드의 시작 값과 끝 값 한 건씩만 가져오면 되기 때문에 Full Table Scan으로 테이블을 모두 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있다.

[장/단점]
-   장점
    -   테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
    -   전반적인 시스템의 부하를 줄일 수 있다.
-   단점
    -   인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
	    **인덱스는 테이블의 전체 데이터 중에서 10~15% 이하의 데이터를 처리하는 경우에만 효율적이고 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 낫다.**
    -   인덱스를 관리하기 위해 추가 작업이 필요하다.
    -   인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.
    - **인덱스는 DML에 취약**
	    INSERT, UPDATE, DELETE를 통해 데이터가 추가되거나 값이 바뀐다면 인덱스 테이블 내에 있는 값들을 다시 정렬을 해야 한다. 그리고 위에 사진처럼 인덱스 테이블, 원본 테이블 이렇게 두 군데의 데이터 수정 작업을 해줘야 한다는 단점도 발생한다. 그렇기 때문에 DML이 빈번한 테이블보다 검색을 위주로 하는 테이블에 인덱스를 생성하는 것이 좋다.

 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생
 
 * , UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해준
 * SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다.
 
[인덱스(index)를 사용하면 좋은 경우 ]
-   규모가 작지 않은 테이블
-   INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
-   JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
-   데이터의 중복도가 낮은 컬럼
-   기타 등등

생성 전략 - **가장 최선은 PK로 인덱스를 거는 것이라고 할 수 있다.**
1.  조건절에 자주 등장하는 컬럼
2.  항상 = 으로 비교되는 컬럼
3.  중복되는 데이터가 최소한인 컬럼 (분포도가 좋은 컬럼)
4.  ORDER BY 절에서 자주 사용되는 컬럼
5.  JOIN 조건으로 자주 사용되는 컬럼

## **Cardinality**

일반적으로 Cardinalit가 높은 컬럼을 우선적으로 인덱싱하는 것이 검색 성능에 유리합니다. Cardianlity가 높은 컬럼의 경우 Index를 통해 데이터를 더 많이 필터링할 수 있기 때문입니다.

Cardinality란 특정 데이터 집합의 유니크(Unique)한 값의 개수를 의미합니다.

예를 들어 사용 여부를 나타내는 useAt 컬럼이 있다고 할 때, useAt 컬럼의 경우 사용, 미사용 두 가지 값을 나타내는데 이러한 경우 중복도가 높으며, Cardinality가 낮습니다. 반면, 개인마다 고유한 값이 존재하는 주민번호 컬럼의 경우 중복도가 낮으며, Cardinality가 높습니다.

(Cardinality 외에도 Index 설정 시에는 여러 부분을 고려하여 효율적인 컬럼 선정이 이뤄져야 합니다.)

##### (자료구조) B-Tree 를 사용하는 이유

1.  검색 속도

-   HashMap은 데이터를 저장할 때 해시 함수를 사용하여 인덱스를 계산하고, 이를 기반으로 데이터를 검색합니다. 이 때, 해시 충돌 문제가 발생할 수 있어서 충돌을 처리하는 추가적인 작업이 필요합니다.
-   B-Tree는 정렬된 데이터 구조를 사용하기 때문에, 데이터 검색 속도가 빠릅니다. 또한, B-Tree는 분기 계수(branching factor)가 높아서, 검색 시에도 일정 수준 이상의 데이터를 한 번에 탐색할 수 있어서 검색 속도가 더욱 빠릅니다.

2.  범위 검색

-   HashMap은 해시 함수를 기반으로 인덱스를 계산하기 때문에, 키 값이 일치하는 데이터만을 검색할 수 있습니다. 범위 검색을 하기 위해서는 모든 데이터를 순차적으로 검색해야 하기 때문에 시간이 오래 걸립니다.
-   B-Tree는 정렬된 데이터 구조를 사용하기 때문에, 범위 검색에 더욱 효과적입니다. B-Tree는 데이터가 정렬되어 있기 때문에, 검색 범위를 한 번에 계산할 수 있으며, 이를 효과적으로 탐색할 수 있습니다.

3.  공간 효율성

-   HashMap은 데이터를 저장할 때 해시 테이블을 사용하며, 충돌이 발생하면 연결 리스트를 사용하여 충돌을 처리합니다. 따라서, 저장된 데이터가 많아질수록 메모리 사용량이 증가하게 됩니다.
-   B-Tree는 일정한 분기 계수를 사용하기 때문에, 저장된 데이터가 많아져도 공간 사용량이 증가하는 비율이 낮습니다. 또한, B-Tree는 데이터를 압축하여 저장하기 때문에, 메모리 사용량을 더욱 효율적으로 관리할 수 있습니다.

##### ✅ B-Tree
- 생성, 수정, 삭제 경우 O(log n) 시간복잡도를 유지
- 데이터를 정렬된 구조로 관리하기에 적은 수의 노드만 변경
- 삭제된 데이터를 실제로 제거하는 작업은 추가적인 비용이 발생

##### ✅ HashMap
- 생성, 수정, 삭제 경우 O(1) 시간복잡도
- 해시 테이블에 저장하여 충돌이 발생하거나 해시 테이블의 크기를 조정 경우 성능 저하가 발생

⭐ Key ⭐
추가, 삭제보다는 검색이 주요한 경우에는 B-Tree
추가, 삭제가 빈번한 경우에는 HashMap


https://mangkyu.tistory.com/96
https://choicode.tistory.com/27
https://coding-factory.tistory.com/746
https://rebro.kr/167
