-----
인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
*  데이터베이스의 index는 책의 색인과 같다
* 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 도움 

![[Pasted image 20230320185023.png]]

* 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능이 함께 향상
	* 연산을 수행하려면 해당 대상을 조회
	* 전체를 탐색하는 Full Scan
		* 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어짐 

[사용 하는 이유]
① 조건 검색 WHERE 절의 효율성
 **인덱스 테이블 스캔(Index Table Scan) 시 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 해당 조건(WHERE)에 맞는 데이터들을 빠르게 찾아낼 수 있는 것**

**② 정렬 ORDER BY 절의 효율성**
인덱스를 사용하면 ORDER BY에 의한 정렬(Sort) 과정을 피할 수가 있다. ORDER BY는 굉장히 부하가 많이 걸리는 작업이다. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면 *디스크 I/O도 추가적으로 발생되기 때문이다. 하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 된다. 왜? 이미 정렬이 되어 있기 때문에 가져오기만 하면 되기 때문이다.

 **③ MIN, MAX의 효율적인 처리가 가능하다**
데이터가 정렬되어 있기에 얻을 수 있는 장점이다. MIN값과 MAX값을 레코드의 시작 값과 끝 값 한 건씩만 가져오면 되기 때문에 Full Table Scan으로 테이블을 모두 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있다.

[장/단점]
-   장점
    -   테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
    -   전반적인 시스템의 부하를 줄일 수 있다.
-   단점
    -   인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
	    **인덱스는 테이블의 전체 데이터 중에서 10~15% 이하의 데이터를 처리하는 경우에만 효율적이고 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 낫다.**
    -   인덱스를 관리하기 위해 추가 작업이 필요하다.
    -   인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.
    - **인덱스는 DML에 취약**
	    INSERT, UPDATE, DELETE를 통해 데이터가 추가되거나 값이 바뀐다면 인덱스 테이블 내에 있는 값들을 다시 정렬을 해야 한다. 그리고 위에 사진처럼 인덱스 테이블, 원본 테이블 이렇게 두 군데의 데이터 수정 작업을 해줘야 한다는 단점도 발생한다. 그렇기 때문에 DML이 빈번한 테이블보다 검색을 위주로 하는 테이블에 인덱스를 생성하는 것이 좋다.

 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생
 * , UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해준
 * SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다.
[### ********인덱스(index)를 사용하면 좋은 경우 ]********

-   규모가 작지 않은 테이블
-   INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
-   JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
-   데이터의 중복도가 낮은 컬럼
-   기타 등등
생성 전략 - **가장 최선은 PK로 인덱스를 거는 것이라고 할 수 있다.**
1.  조건절에 자주 등장하는 컬럼
2.  항상 = 으로 비교되는 컬럼
3.  중복되는 데이터가 최소한인 컬럼 (분포도가 좋은 컬럼)
4.  ORDER BY 절에서 자주 사용되는 컬럼
5.  JOIN 조건으로 자주 사용되는 컬럼

[자료구조]
 * 해시 테이블
	 * 빠른 데이터 검색이 필요할 때 유용함 
	 * 해시 테이블은 Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조
	 ![[Pasted image 20230320185331.png]]
* DB 인덱스는 (데이터=컬럼의 값, 데이터의 위치)를 (Key, Value)로 사용하여 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현
* 시간 복잡도 : O(1)
	 
 * B+TreE


## **Cardinality**

일반적으로 Cardinalit가 높은 컬럼을 우선적으로 인덱싱하는 것이 검색 성능에 유리합니다. Cardianlity가 높은 컬럼의 경우 Index를 통해 데이터를 더 많이 필터링할 수 있기 때문입니다.

Cardinality란 특정 데이터 집합의 유니크(Unique)한 값의 개수를 의미합니다.

예를 들어 사용 여부를 나타내는 useAt 컬럼이 있다고 할 때, useAt 컬럼의 경우 사용, 미사용 두 가지 값을 나타내는데 이러한 경우 중복도가 높으며, Cardinality가 낮습니다. 반면, 개인마다 고유한 값이 존재하는 주민번호 컬럼의 경우 중복도가 낮으며, Cardinality가 높습니다.

(Cardinality 외에도 Index 설정 시에는 여러 부분을 고려하여 효율적인 컬럼 선정이 이뤄져야 합니다.)


https://mangkyu.tistory.com/96
https://choicode.tistory.com/27
https://coding-factory.tistory.com/746
https://rebro.kr/167
