

> 자바 초창기에는 메서드 디스패치 성능은 정말 최악이였습니다. 
> 그래서 메서드를 잘게 나누지 말고
> 하나의 큰 메서드로 작성하는게 좋겠다고 권고하는 개발자가 있었다. 
> 시간이 지나면서 가상 디스패치 성능은 엄청 좋아졌고
> JVM 에서는 자동 인라이닝 (automatic managed inlining) 덕분에 
> 가상 디스패치조차 대부분의 호출부(call site) 에서 사라지게 되었다. 
> "모든 코드를 하나의 메서드에 욱여넣어라"는 현대식 JIT 컴파일러와는 어울리지 않게 되었다. 

###### ✅ 메서드 디스패치 
어떤 메서드를 호출할지 결정하여 실제로 실행시키는 과정.
자바는 런타임시 객체를 생성하고 컴파일 시 객체 타입에 대한 정보만 보유하여
==staitc== 과 ==dynamic== 이 있다. 

`Static Dispatch`
컴파일 시점에서, 컴파일러가 ==특정 메서드를 호출==할 것이라고 명확하게 알고 있는 경우 

`Dynamic Dispatch`
컴파일러가 어떤 메서드를 호출할지 모르는 경우여서 ==호출할때 메서드를 런타임 시점에 결정==한다.

- 인터페이스나 추상 클래스에 정의된 추상 메서드를 호출 하는 경우로 인터페이스 또는 추상 클래스로 선언하고 하위 클래스의 인스턴스




> 자바 환경이 고성능 컴퓨팅 애플리케이션에 적합한 수준에 이른건 비교적 최근에 핫스팟 같은 정교한 JVM 이 성숙했기 때문이다.


✅ 자바는 실용성을 추구하는 플랫폼 
* 서브 시스템 
	* 용량같은 세세한 관리 부담감을 줄여주는 대신 저수준으로 제어 가능한 일부 포기 
	* 메모리 관리 => 가바지 수집 서브 시스템(GC) 형태로 메모리 자동 관리 
	* 런타임 동작에 복잡도 유발 
	* JVM 성능 측정은 정규 분포를 따르지 않아 측정 결과를 제대로 처리하기에 역부족 

📌 성능 지표 
* 처리율 
	* 서브시스템이 수행 가능한 작업 비율 
	* 시간동안 완료한 작업 단위 수 ex) 초당 처리 가능한 트랜잭션 수(=TPS)
	* 처리할 때 일정한 워크로드와 일정한 스팩이 유지되애 한다. 
* 지연
	* 하나의 트랜잭션을 처리하고 그 길이에 대해 소요된 시간 
* 용량 (= 트랜잭션)
	* 시스템이 보유한 작업 병렬성의 총량 (동시 처리 가능한 작업 단위 개수)
	* 부하가 증가할 수록 처리율도 영향을 받는다. 
* 사용률
	* 리소스 효율적으로 활용 
* 효율
	* 효율 = 처리율 / 리소스 사용률 
* 확장성
	* 처리율에 따른 리소스 사용률은 시스템의 확장성을 가늠하는 척도
	* 리소스를 투입한 만큼 처리율이 변경되는 형태 지향 
* 저하 
	* 더 많은 부하에 따른 지연 그리고 처리율 측정값에 생긴 변화 
	* 시스템이 풀 가동된 상태에 처리율은 늘지않고 지연이 증가하는 양상 

➡️ `핫스팟 JIT 컴파일러` : 인터프리티드 모드로 실핼해야 부하가 많을 경우 호출 빈도가 증가하면서 JIT 컴파일러 대상이 될수 있다. 그러므로 나중에 호출하는게 처음보다 빨리 실행 된다. 

##### JVM 

* 스택 기반의 해석 머신
* 레지스터가 없지만 일부 결과를 실행 스택에 보관하며 쌓인 값을 계산한다. 
* 평가 스택을 이용해 중간 값을 담아두고 가장 마지막에 실행된 명렁어와 옵코드 (opcode)를 하나씩 순서대로 처리 =="while 룹 안의 switch 문"==

* main() => 애플리케이션의 진입점 
	* 제어권을 해당 클래스로 넘기려면 가상 머신이 실행 시작 전 이 클래스를 로드해야함. 
		* `java classloading` 매커니즘
			* 1) 부트스트랩 클래스가 자바 런타임 코어 클래스 로드
			* 