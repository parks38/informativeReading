
> B-Tree / B+Tree 란? 

*B-Tree/ B+Tree* 모두 탐색 성능을 높이기 위해 균형있게 높이를 유지하는 balanced tree의 일종입니다. 

==두가지 모두 인덱스를 이루고 있는 자료구조의 입니다.==

B-Tree는 모든 leaf node 가 같은 level 로 유지되도록 자동으로 밸런스를 맞춰주며 하나의 노드에 많은 정보를 담습니다. 이렇게 하나의 노드에 여러 정보를 담게 되고, 여러 자식을 가질 수 있게 되면서 차수라는 개념 최대 M개의 자식을 가질 수 있는 B-Tree를 M차 B-Tree라고 불립니다. 

B+tree는 기존의 B-Tree와 데이터의 연결리스트로 구현된 색인구조로 **index 부분**과 **leaf 노드로 구성된 순차 데이터 부분**으로 이루어진다. 인덱스 부분의 key 값은 leaf에 있는 key 값을 직접 찾아가는데 사용합니다. 키값은 중복될수 있지만 리프노드까지 내려갸야 한다는 단점이 있습니다. 하지만 같은 레벨의 모든 키값들이 정렬되어 있고, 같은 레벨의 Sibiling node는 연결리스트 형태로 이어져 있습니다.

![[Pasted image 20230316185130.png]]


> B-Tree/ B+Tree 차이점? 

B-tree는 작은 블록 크기와 적은 데이터를 다루는 경우에 유용하며, B+tree는 대량의 데이터와 범위 검색이 자주 수행되는 경우에 적합합니다. 그이유는 
[1] B-tree는 키와 데이터 모두 노드에 저장하지만 B+tree는 키만 저장하기에 더 많은 데이터를 저장할 수 있습니다. 
[2] B-tree는 리프 노드가 연결되어 있지 않고 B+tree는 모든 리프가 연결되어 있어 범위 검색을 빠르게 수행 할 수 있습니다. 
[3] B+tree 는 리프노드만 실제 데이터를 가지고 있기에 메모리에서 한번에 처리할 수 있는 레코드 수가 증가합니다. 반면 B-tree는 하나의 노드에 여러 자료를 배치하며 더효율적으로 데이터를 저장소에 담을 수 있습니다. 

-----

B-tree (balanced tree)란?

>  **탐색 성능을 높이기 위해 균형 있게 높이를 유지하는 Balanced Tree의 일종이다.** 모든 leaf node가 같은 level로 유지되도록 자동으로 밸런스를 맞춰준다. 자식 node의 개수가 2개 이상이며, node 내의 key가 1개 이상일 수 있다.

* node의 자식 수 중 최댓값을 K일 경우 , **K차 B-Tree**
	* "자식을 여러 개 가지면서 높이를 줄이자!" 해서 나온 게 바로 B-Tree
* 균형이진트리의 연속이라 Worst Case: O(logN)

###### ✅ B-tree 의 조건 

**1. node의 key의 수가 k개라면, 자식 node의 수는 k+1개이다.** 
![[Pasted image 20230316173514.png]]

**2. node의 key는 반드시 정렬된 상태여야 한다.** 
![[Pasted image 20230316173527.png]]

**3. 자식 node들의 key는 현재 node의 key를 기준으로 크기 순으로 나뉘게 된다.** 
![[Pasted image 20230316173546.png]]

**4. root node는 항상 2개 이상의 자식 node를 갖는다. (root node가 leaf node인 경우 제외)** 
![[Pasted image 20230316173604.png]]

5. M차 B-Tree라면 루트 노드와 리프 노드를 제외하고 최소 M/2개 이상의 데이터를 가지고 있어야 한다.
![[Pasted image 20230316173726.png]]

![[Pasted image 20230316173625.png]]

**6. 모든 leaf node들은 같은 level에 있어야 한다.**
![[Pasted image 20230316173803.png]]
7. 리프 노드의 데이터 수는 M-1 이하여야 한다.

###### ✅ B-tree 탐색 과정

![[Pasted image 20230316190656.png]]
**1) root node부터 탐색을 시작한다.** 
**2) node의 key를 순회하여 K가 존재하면 탐색을 종료한다.** 
**3) k가 존재하지 않는다면, 어떤 이웃한 두 key 사이에 K가 들어가는 경우 사이의 포인터를 통해 자식 node로 내려간다.** 
**4) leaf node까지 2~3을 반복한다.**

![[Pasted image 20230316173903.png]]


###### ✅ B-tree 의 key 삽입
B-Tree는 균형을 유지해야 하기 때문에 key를 삽입하는 경우 트리의 변형이 발생한다. 

**1. 빈 트리인 경우 root node를 만들어 K를 삽입한다. root node가 가득 찬 경우 node를 분할하여 leaf node를 생성한다.** 
**2. K가 들어갈 leaf node를 검색 과정과 동일하게 탐색한다.** 
**3. 해당 leaf node에 자리가 남아있다면 정렬을 유지하도록 알맞은 위치에 삽입하고, leaf node가 꽉 차 있다면 K를 삽입한 후 해당 node를 분할한다.** 
**4. node가 분할되는 경우 node의 중앙값을 기준으로 분할한다. 중앙값은 부모 node로 합쳐지거나 새로운 node로 생성되고, 중앙값을 기준으로 왼쪽의 key는 왼쪽 자식, 오른쪽의 key는 오른쪽 자식으로 생성된다.**

1. 리프 노드가 M-2개 이하인 경우
    - 그냥 삽입하낟. 
![[Pasted image 20230316174024.png]]

2. 리프 노드가 M-1개인 경우
삽입한 뒤에 중앙값을 기준으로 분할하고 중앙값은 부모노드로 합쳐지거나 새로운 노드로 생성되고
해당 중앙값에 따라서 자식 노드가 배치됩니다.
![[Pasted image 20230316174158.png]]
![[Pasted image 20230316174206.png]]
![[Pasted image 20230316174215.png]]


###### ✅ B-tree 의 key 삭제 
1. 리프 노드인 경우
	1-1) 삭제하려는 데이터가 있는 노드의 수가 최소보다 큰 경우
		그냥 삭제해주고 자식 노드를 데이터에 맞게 재배치 합니다. 
			
	1-2) 삭제하려는 데이터가 있는 노드의 수가 최소이고 형제 노드의 수가 최소보다 많을 때
	- 삭제하려는 노드의 인덱스를 가진 부모 노드의 데이터로 바꿔줌. 
	- 형제 노드 중 최소보다 많은 노드가 왼쪽 데이터면 가장 큰값 오른쪽 데이터 경우 가장 작은 값을 바꿔준 부모 노드 자리에 채워주고 데이터 재배치 
	
	1-3) 삭제하려는 노드와 형제 노드의 수가 모두 최소이고, 부모의 노드가 최소보다 큰 경우
		* 삭제하려는 노드 인덱스 위치를 가진 부모의 데이터를 대체해주고 재배치 

	1-4) 삭제하려는 노드,형제,부모 노드 모두 최소인 경우
	* 데이터 삭제 하고 부모노드와 자식 노드 합침
	* 형제 노드의 자식들로 합쳐줌
	* 현재 노드 번째의 부모 노드 인덱스를 내려줌
	* 데이터 재배치 
1. 리프 노드가 아닌 경우
	2-1) 삭제하려는 노드 또는 자식 노드의 수가 최소보다 큰 경우
	 * 삭제 후 자식의 왼쪽 노드에서 가장 큰 값 또는 오른쪽 노드에서 가장 작은 값으로 대체 
	 
	2-2) 삭제하려는 노드와 자식 노드가 모두 최소일 경우
	* 삭제하고 자식들을 하나로 묶어줌 
	* 삭제한 노드의 인덱스를 가진 부모 노드의 데이터를 형제 노드와 함쳐준 후 자식노드를 그 아래로 묶어줌 

###### ✅ B-tree 사용 
`InnoDB (MySQL 스토어리지 엔진)`
*  B-tree called B+tree indexes 활용
	* B+tree 이용해서 쿼리 속도를 향상 시킴 (검색, 컴럼 지정 정렬)
* 대규모 데이터에서의 최적의 인덱스 기능
	* 쉽게 밸런스와 최적화 된다. 
	* 서치 키를 이용하여 데이터 활용이 좋음. 

`SQL SERVER DATABASE ENGINE (MSSQL)`
* B+tree 의 변형이자 인덱스 활용 
* clustered and non-clustered indexes에 모두 사용
	* 검색 키에 대해 효율적인 접근을 제공함. , and they provide efficient access to data based on the search key.
* 활용 예시:  hash indexes,  full-text indexes

###### ✅ B-tree KeyPoint 
* 대규모 데이터를 저장하고 불러올수 있음. 
* 균형이진트리로 검색, 삽입, 삭제 효율이 높음 
* 테이블 인덱스 시 사용 
	* 데이터 검색과 정렬에 효율적 
	* 테이블 완전탐색이 아닌 관련 데이터를 빠르게 확인
* 디스크 관련 스토리지에 최적화 됨. 
	* B-tree는 디스크 접근을 줄여 대규모 데이터를 관리할경우 최적화 됨. (메모리 접근보다 디스크 접근이 비용이 비쌈)

> B-tree가 디스크 관련 스토리지에 최적화 되어 있는 이유? 

1.  블록 단위 접근: B-tree는 블록 단위로 데이터를 저장하므로 디스크에서 데이터를 읽거나 쓸 때 블록 단위로 접근할 수 있습니다. 이는 디스크 I/O를 최소화하므로 빠른 검색과 삽입, 삭제 연산을 가능하게 합니다.
2.  균형 잡힌 트리 구조: B-tree는 균형 잡힌 트리 구조를 유지하므로 모든 노드의 깊이가 균등합니다. 이는 탐색 속도를 일정하게 유지하므로 디스크 I/O 비용을 최소화합니다.
1.  범위 검색: B-tree는 범위 검색이 효율적으로 수행됩니다. 이는 블록 단위로 데이터가 정렬되어 있으므로 연속된 블록을 순차적으로 읽을 수 있기 때문입니다.

하나의 노드에 여러 자료를 배치하게 되면서 이진 트리보다 훨씬 많은 데이터를 더 효율적으로 저장소에 담을 수 있게 되었습니다.

하드디스크나 SSD와 같은 외부 기억장치는 블럭단위로 파일을 입출력합니다. 이때 발생하는 입출력의 비용은 파일의 크기와는 상관 없이 동일합니다. 입출력에 있어서는 1KB짜리 블럭에 1byte짜리 알파벳 하나가 들어가 있어도 1KB가 꽉 차있는 블럭과 차이가 없다는 것이죠.
이 떄 하나의 블럭에 여러 데이터들을 동시에 저장할 수 있다면 블럭을 보다 효율적으로 사용할 수 있겠죠?
그래서 많은 데이터베이스들은 B-Tree를 애용합니다.

###### ✅ B+tree
데이터의 빠른 접근을 위한 **인덱스 역할만 하는 비단말 노드(not Leaf)**가 추가로 있음
* 기존의 B-Tree와 데이터의 연결리스트로 구현된 색인구조
* B+Tree는 같은 레벨의 모든 키값들이 정렬되어 있고, 같은 레벨의 Sibiling node는 연결리스트 형태로 이어져 있습니다.

B-Tree의 변형 구조로, **index 부분**과 **leaf 노드로 구성된 순차 데이터 부분**으로 이루어진다. 인덱스 부분의 key 값은 leaf에 있는 key 값을 직접 찾아가는데 사용함.

* leaf node가 아닌 자료는 인덱스 노드
	* 인덱스 노드의 Value값에는 다음 노드를 가리킬 수 있는 포인터 주소가 존재
* leaf node 자료는 데이터 노드
	* 데이터 노드의 Value값에 데이터가 존재하는 것

따라서 키값은 중복될 수 있고 (인덱스 노드와 데이터 노드에서 동시에 등장 가능!!!), 데이터 검색을 위해서는 반드시 leaf node까지 내려가야 한다는 특징을 가지고 있습니다.

* 검색속도이기 때문에 대부분의 데이터베이스 시스템은 B+Tree구조를 채택

![[Pasted image 20230316181929.png]]

[특징]
- 데이터 노드의 자료는 정렬되어 있습니다.
- 데이터 노드에서는 데이터가 중복되지 않습니다.
- 모든 leaf node는 같은 레벨에 있습니다.
- leaf node가 아닌 node의 키값의 수는 그 노드의 서브트리수보다 하나가 적습니다.
- 모든 leaf node는 연결리스트로 연결되어 있습니다.
 
[장점] 
* 블럭 사이즈를 더 많이 이용할 수 있음 (key 값에 대한 하드디스크 액세스 주소가 없기 때문)
* leaf 노드끼리 연결 리스트로 연결되어 있어서 범위 탐색에 매우 유리함

[단점] 
* B-tree의 경우 최상 케이스에서는 루트에서 끝날 수 있지만, B+tree는 무조건 leaf 노드까지 내려가봐야 함

###### ✅ B-tree와 B+tree 차이점

- 데이터 저장 정보 : 
	- B-tree는 키와 데이터가 모두 노드에 저장
	- B+tree는 키만 노드에 저장되고 데이터는 리프 노드에 저장
		- B+tree는 더 많은 데이터를 저장할 수 있습니다.
		
- 범위 검색: 
	- B-tree에서는 리프 노드가 서로 연결되어 있지 않음
	- B+tree에서는 모든 리프 노드가 서로 연결되어 있습니다. 이로 인해 범위 검색이 빠르게 수행

 - 처리량: 
	 - B+tree에서는 리프 노드만이 실제 데이터를 가지고 있음
		 - 블록 크기가 크면 메모리에서 한 번에 처리할 수 있는 레코드 수가 증가합니다. 이는 더 높은 처리량을 제공합니다.
	 
* 삽입과 삭제 연산 속도 : 
	* B+tree는 모든 리프 노드가 같은 레벨에 위치하여 균형 잡힌 트리 구조를 유지가 쉬움
		* 삽입과 삭제 연산이 더 빠름. 
    
따라서, B-tree는 작은 블록 크기와 적은 데이터를 다루는 경우에 유용하며, B+tree는 대량의 데이터와 범위 검색이 자주 수행되는 경우에 적합합니다.

-----

[참고] https://fomaios.tistory.com/entry/Data-Structure-B-Tree%EB%9E%80