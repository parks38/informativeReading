----

> 답변 

spring 에서 인터페이스를 활용한 예시는 [1]  DI 의 기능 확장 [2] ServiceImpl - Service 패턴 사용 [3] AOP가 있다. 
인터페이스는 다중상속이 가능하며 책임과 역할을 분리하여 느슨한 결합도를 가지게 해준다. 
그러므로 다형성과 확장성을 구현해야 하는 경우 사용한다. 

DI 구현시 인터페이스를 사용해야 하는 이유는 [1] 다형성과 [2] 오브젝트의 기능이 발전하는 과정에서 다른 종류의 클라이언트가 등장하여 `확장`이 필요 할수 있다는 것이다. 

ServiceImpl implements Service 패턴을 사용하는 이유는 oop 관점의 OCP 와 DIP 를 올바르게 사용하여 `service`에 의존하는 class는 더 이상 `service`의 구현에 의존하여 독립적으로 사용할 수 있게 해주기 때문이다. 

AOP 구현 시 JDK의 기본 프록시를 사용하는데 이는 인터페이스 기반으로 동작하기 때문에 Service인터페이스를 만들어 사용한다.


[Index]
- interface v.s AbstractClass 차이점
- interface 활용 1 : DI
- interface 활용 2 : ServiceImpl (interface) 패턴 사용 이유
	- OCP/ DIP 
	- AOP/ 결합도 

[개요]
대부분 프로젝트에서 Service들에 대해서 모두 인터페이스를 만들고 이에 대해 ServiceImpl(예) 식으로 따로 생성한 인터페이스를 구현한 모습을 볼 수 있습니다. 왜 이 방법을 활용하는 것인가? 

###### ➡️ Interface vs. Abstract

/ 이슬님 자료 [[인터페이스와 추상 클래스]]

답변 : 
추상 클래스는 `abstract` 키워드로 선언된 클래스이며 추상 메서드를 자식 클래스가 구체화 하여 그 기능을 확장하는 목적이 있습니다. 
인터페이스는 상속받은 서브 클래스에서 구현할 메서드들의 원형을 모두 알려주며, 클래스가 자신의 목적에 맞게 메서드를 구현하도록 하는 것입니다. 

[기능]
**추상클래스는 IS - A "~이다".** (단일 상속)
- 상속 관계를 쭉 타고 올라갔을때 같은 조상클래스를 상속하는데 기능 똑같은 기능이 필요한 경우(ex. attack, printInfo)

**인터페이스는 HAS - A "~을 할 수 있는".** (다중상속)
- 상속 관계를 쭉 타고 올라갔을때 다른 조상클래스를 상속하는데 같은 기능이 필요할 경우 인터페이스 사용 (ex. Swimable)

###### ➡️ 활용 1: DI - 인터페이스 상속을 통한 안전한 기능 확장 

✅DI [출처] 토비의 스프링 
- DI 기능 : 객체를 외부에서 생성한 후 주입
	- 모듈간의 결합도가 낮아지고 유연성이 높아짐. 
	- 내부 기능을 적절한 `책임` 과 `역할`에 따라 분리하고 `인터페이스`를 정의해 느슨하게 연결해 주고, DI 를 통해 유연하게 의존관계를 지정하도록 설계 
		- 세부적인 구현에 얽매이지 않고 유연한 의존관계를 맺으며 독립적으로 발전 
		
- 스프링 DI 적용 
	- 사용할 오브젝트를 프로퍼티로 정의하고 xml 빈 설정 주입  
	- di 의식한 설계 
		- 두개 이상의 의존 관계를 가지고 협력 
		- 적절한 책임에 따라 오브젝트 분리
		- 런타임 시, 의존 오브젝트를 다이나믹하게 연결해 유연한 확장의 목적을 염두하고 관계 설정 
		- 유연한 확장과 재사용 가능 설계 
		
- DI와 인터페이스 
	- DI 적용시 가능한 인터페이스 사용 필요
	- 사용 이유: 
		- 1. 다형성 
			- 핵심 로직 이외에도 프록시, 데코레이터,어댑터, 테스터 대역 다양한 목적을 위해 `인터페이스 통한 다형성 활용` 
			- 상속 불가능한 final 클래스 이외에는 여러가지로 구현 확장 가능 
				=> 템플렛 메소드
			- "인터페이스는 하나의 오브젝트가 여러 개를 구현할 수 있으므로 바라보는 창이 여러개"
				=> 각기 다른 관심과 목적을 가지고 어떤 오브젝트에 의존하고 있을 수 있다. 
				- 응집도 높은 작은 단위로 설계 되었어도 목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 적절히 분리 => `인터페이스 분리 원칙`
		- 2. 오브젝트의 기능이 발전하는 과정에서 다른 종류의 클라이언트 등장 
			- 인터페이스 여러개 만들기 보다 기존 인터페이스를 상속하여 확장 방법 가능 
			- `인터페이스 분리 원칙`
				- 자신의 고나심에 따른 접근 방식을 불필요한 간섭 없이 유지
				- 기존 클라이언트에 영향 주지 않은 채로 오브젝트의 기능을 확장하거나 수정 
			* ex. 
			![[Pasted image 20230320111047.png]]
			- 인터페이스를 사용해 di 관계를 만들어 sqlregistry 의 구현 클래스인 MySqlRegistry의 오브젝트가 제3의 클라이언트를 위한 인터페이스를 가질 수 이싿. 
			- MySqlRegistyr 기능이 확ㅈ아되며 새로운 클라이언트가 나타나 기존 SqlRegistry 확장 인터페이스 사용 필요 할 수 있다. 
			- 새롭게 추가할 기능에 대해서는 새로운 인터페이스를 정의하거나 기존 인터페이스를 확장하는 것이 바람직하다. 
			- ex.
			![[Pasted image 20230320111330.png]]
			-  SQL 업데이트 작업이 필요한 경우 UpdateableSqlRegistry 인터페이스를 통해 SQL 레지스트리 오브젝트에 접근하도록 하고 SQL 변경에 대한 요청은 웹이나 원격 호출 등의 다양한 방법을 통해 일어난다. 
				- `SQLAdmin Service -> UpdateableSqlRegustry -> SqlRegistry 접근 `
				- BaseSqlService 와 SqlAdminService 는 동일한 오브젝트를 의존하지만 관심과 필요에 따라 다른 인터페이스를 통한 접근 필요 
				- 인터페이스 추가 및 상속을 통한 확장 방식을 잘 활용하면 `유연한 확장 가능`
				- DI 와 객체지향 설계는 밀접한 관계가 있다. 

[공통된 기능 사용 여부]

###### ➡️ 활용 2: ServiceImpl 

> 왜 interface를 사용하여 미리 함수의 원형을 정의하고 그것을 impl한 class를 구체클래스로 구현을 하는가?
* service (interface)
* serviceImpl (class)

인터페이스를 규약해놓고 그것에 맞추어 여러 구현체를 구현하고, 다른 클래스에서 사용할 때 실제 구현체에 상관없이 개발할 수 있다는 OOP적 관점에서 사용한다. 
- 인터페이스라는 규약에 맞추어 개발 => Impl 클래스의 실제적 구현을 상관 없이 구현 
- 인터페이스 함수를 가져다가 개발을 진행하고 그후 서비스 로직을 실제로 구현하는 것이다 
	- 구체 클래스에 의존하지 않고 개발 가능
	- controller 클래스는 함수를 가져다가 쓰면 됨. 
- OOP 적 관점 
	- ocp(개방 폐쇄의 원칙) : _소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다._
	- dip (의존관계 역전의 원칙) : _저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 하고 그 반대가 되면 안된다_
	- EX. 스프링을 사용하며 객체의 생성 제어를 IoC컨테이너에게 위임하고 컨트롤러에서 런타임 중에 어떤 자바빈을 주입할 지 인터페이스에게 위임하여 느슨한 결합도를 가지도록 함 

[키워드]
- 느슨한 결합
	- `Interface`를 사용함으로써, `service`에 의존하는 class는 더 이상 `service`의 구현에 의존하지 않게 된다. 
	   이것이 `service`를 독립적으로 사용할 수 있게 해준다.
	
[interface 를 service 에 사용해야 하는 경우]
- 여러 방식의 구현 
- 제어의 역전 / IoC : 개발자가 직접 어하는 것이 아닌 외부에서 제어 및 관리는 해주는 것 
	- Spring IOC Container가 객체를 관리함으로써  DI(의존성 주입) , AOP(관점 지향 프로그래밍)이 가능

인터페이스 타입에 어떤 구현 객체를 대입하는지에 따라 실행결과가 달라지도록 만드는 기술이므로 기존 구현 객체(ServiceImpl1)와 **비즈니스 로직이 다른 기능을 추가해야할 경우** 다른 구현 객체(ServiceImpl2)를 만들어 사용하면 된다. 따라서 유지보수 측면에서 매우 좋다.

###### ➡️ 활용 3: AOP 
* AOP와 트랜잭션은 서비스 인터페이스에서 처리
* 스프링에서 AOP를 구현할 때 JDK의 기본 프록시를 사용하는데, 이 프록시는 인터페이스 기반으로 동작하기 때문에 Service인터페이스를 만들어 사용

**AOP란** 기존에 OOP에서 바라보던 관점을 다르게 하여 부가기능적은 측면에서 보았을 때 공통된 요소를 추출하자는 것입니다.
- AOP : 인프라, 부가 기능의 모둘화
	- 공통 기능 재사용 기법
	- 부가적인 기능을 분리하여 Aspect 라는 모듈로 설계하고 개발 

> Spring의 AOP 프록시 구현 (jdk 동적 프록시/ CGLib 프록시)

 Spring은 프록시 타깃 객체에 인터페이스가 있다면 그 인터페이스를 구현한 JDK 다이내믹 프록시 방식으로 객체를 생성하고, 인터페이스가 없다면 CGLib을 이용한 클래스 프록시를 만든다.

1.  인터페이스를 구현하고 있는지 확인함
2.  인터페이스를 구현하고 있으면 JDK 다이내믹 프록시 방식으로 객체를 생성
3.  인터페이스를 구현하지 않으면 GCLib 방식으로 객체를 생성

하지만 JDK 동적 프록시 방식은 다음과 같은 2가지 한계점을 가지고 있다.

-   프록시를 적용하기 위해서 반드시 인터페이스를 생성해야 함
-   구체 클래스로는 빈을 주입받을 수 없고, 반드시 인터페이스로만 주입받아야 함



![[Pasted image 20230320182922.png]]





[참고]
https://velog.io/@kshired/Spring-Java-Interface-AbstractClass%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EA%B3%BC-ServiceImpl-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0
https://velog.io/@hsw0194/Spring-Boot%EC%97%90%EC%84%9C-interface%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C

https://velog.io/@hsw0194/Spring-Boot%EC%97%90%EC%84%9C-interface%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C

https://jung-story.tistory.com/129

https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-vs-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0

https://velog.io/@suhongkim98/%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B5%AC%ED%98%84-%EC%8B%9C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-spring-AOP

https://tecoble.techcourse.co.kr/post/2022-11-07-transaction-aop-fact-and-misconception/

[프록시 구현]
https://mangkyu.tistory.com/175
