----

- interface v.s AbstractClass 차이점
- ServiceImpl (interface) 패턴 사용 이유
- AOP/ 결합도 


> ⁉️ **대부분 Spring프로젝트를 진행하다 보면 프로젝트의 Service들에 대해서 모두 인터페이스를 만들고 이에 대해 ServiceImpl(예) 식으로 따로 생성한 인터페이스를 구현한 모습을 볼 수 있습니다.**

> Interface? 

다른 클래스를 작성할 때 기본이 되는 틀을 제공하고, 다른 클래스 사이의 중간 매개 역할을 하는 일종의 추상 클래스와 유사한 역할 ex.  추상 메소드와 상수만을 포함


✅ 토비의 스프링 

> 인터페이스 상속을 통한 안전한 기능 확장 

- DI 와 기능의 확장 
	- 모든 기능을 클래스 하나안에 만들기 보다 내부 기능을 적절한 `책임` 과 `역할`에 따라 분리하고 `인터페이스`를 정의해 느슨하게 연결해 주고, DI 를 통해 유연하게 의존관계를 지정하도록 설계 
		- 세부적인 구현에 얽매이지 않고 유연한 의존관계를 맺으며 독립적으로 발전 => DI 역할 
- 스프링 DI 적용 
	- 사용할 오브젝트를 프로퍼티로 정의하고 xml 빈 설정을 이용해 주입 
	- di 의식한 설계 
		- 두개 이상의 의존 관계를 가지고 협력 
		- 적절한 책임에 따라 오브젝트 분리
		- 런타임 시, 의존 오브젝트를 다이나믹하게 연결해 유연한 확장의 목적을 염두하고 관계 설정 
		- 유연한 확장과 재사용 가능 설계 
- DI .와 인터페이스 
	- DI 적용시 가능한 인터페이스 사용 필요 => 특별한 이유가 없다면 항상 인터페이스 사용 
	- 사용 이유: 
		- 1. 다형성 
			- 핵심 로직 이외에도 프록시, 데코레이터,어댑터, 테스터 대역 다양한 목적을 위해 인터페이스 통한 다형성 활용 
			- 상속 불가능한 final 클래스 이외에는 여러가지로 구현 확장 가능 => 템플렛 메소드
			- "인터페이스는 하나의 오브젝트가 여러 개를 구현할 수 있으므로 바라보는 창이 여러개"
				=> 각기 다른 관심과 목적을 가지고 어떤 오브젝트에 의존하고 있을 수 있다. 
				- 응집도 높은 작은 단위로 설계 되었어도 목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 적절히 분리 => `인터페이스 분리 원칙`
		- 2. 오브젝트의 기능이 발전하는 과정에서 다른 종류의 클라이언트 등장 
			- 인터페이스 여러개 만들기 보다 기존 인터페이스를 상속하여 확장 방법 가능 
			- `인터페이스 분리 원칙`
				- 자신의 고나심에 따른 접근 방식을 불필요한 간섭 없이 유지
				- 기존 클라이언트에 영향 주지 않은 채로 오브젝트의 기능을 확장하거나 수정 
			* ex. 
			![[Pasted image 20230320111047.png]]
			- 인터페이스를 사용해 di 관계를 만들어 sqlregistry 의 구현 클래스인 MySqlRegistry의 오브젝트가 제3의 클라이언트를 위한 인터페이스를 가질 수 이싿. 
			- MySqlRegistyr 기능이 확ㅈ아되며 새로운 클라이언트가 나타나 기존 SqlRegistry 확장 인터페이스 사용 필요 할 수 있다. 
			- 새롭게 추가할 기능에 대해서는 새로운 인터페이스를 정의하거나 기존 인터페이스를 확장하는 것이 바람직하다. 
			- ex.
			![[Pasted image 20230320111330.png]]
			-  SQL 업데이트 작업이 필요한 경우 UpdateableSqlRegistry 인터페이스를 통해 SQL 레지스트리 오브젝트에 접근하도록 하고 SQL 변경에 대한 요청은 웹이나 원격 호출 등의 다양한 방법을 통해 일어난다. 
				- `SQLAdmin Service -> UpdateableSqlRegustry -> SqlRegistry 접근 `
				- BaseSqlService 와 SqlAdminService 는 동일한 오브젝트를 의존하지만 관심과 필요에 따라 다른 인터페이스를 통한 접근 필요 
				- 인터페이스 추가 및 상속을 통한 확장 방식을 잘 활용하면 `유연한 확장 가능`
				- DI 와 객체지향 설계는 밀접한 관계가 있다. 

###### ✅ Interface vs. Abstract

> Abstract Class 

추상클래스도 살펴보면 상속을 통해서 구현되는 구체 클래스가 추상 메소드를 구현하는 것을 강제하는데, 인터페이스와 달리 생성자, 필드, 일반 메소드도 포함할 수 있습니다.

* **상속을 통해서 자손 클래스에서 완성하도록 유**
* 미완성 설계도 : 상속을 위한 클래스이므로 따로 객체를 생성 할 수 없음 
```java
abstract class 클래스이름 {
    public abstract void 메서드이름();
}
```

![[Pasted image 20230320184118.png]]

| 구분 | 인터페이스                                                            | 추상 클래스                 |
| ---- | --------------------------------------------------------------------- | --------------------------- |
| 용도 | 껍대기 함수의 구현 강제하는데 사용 <br> - 구현은 다르지만 동일한 동작 보장 | 클래스를 상속받아 기능 확장 |
| 상속 | 다중 상속 X                                                           | 다중상속                    |
|      | 내부 구현은 알 필요 없이 설계도                                       | 부모 클래스에서 정의한 내용을 자식 클래스에서 구현하고 확장<br> 다른 가능 확장및 추가 가능                            |
![[Pasted image 20230320184300.png]]


[기능]
**추상클래스는 IS - A "~이다".**
**인터페이스는 HAS - A "~을 할 수 있는".**

추상클래스 사용 시기 : 상속 관계를 쭉 타고 올라갔을때 같은 조상클래스를 상속하는데 기능까지 완변히 똑같은 기능이 필요한 경우
(ex. attack, printInfo)

인터페이스 사용 시기 : 상속 관계를 쭉 타고 올라갔을때 다른 조상클래스를 상속하는데 같은 기능이 필요할 경우 인터페이스 사용
(ex. Swimable)

[공통된 기능 사용 여부]


> 왜 interface를 사용하여 미리 함수의 원형을 정의하고 그것을 impl한 class를 구체클래스로 구현을 하는가?

* service (interface)
* serviceImpl (class)

인터페이스를 규약해놓고 그것에 맞추어 여러 구현체를 구현하고, 다른 클래스에서 사용할 때 실제 구현체에 상관없이 개발할 수 있다는 OOP적 관점에서 사용한다. 
- 인터페이스라는 규약에 맞추어 개발되었기에 우리는 Impl 클래스의 실제적 구현을 상관하지 않고 구현할 수 있다는 것
- Controller 단에서 ServiceImpl 규약에 맞춰 잘 구현했을테니 인터페이스 함수를 가져다가 개발을 진행하며 그후 서비스 로직을 실제로 구현하는 것이다 => 구체 클래스에 의존하지 않고 개발 가능
	- service 구체 클래스 어떤 내부 로직으로 동작하는지 관심 가질 필요 없이 controller 클래스는 그냥 함ㅅ구를 가져다가 쓰면 됨. 

[키워드]
- 느슨한 결합
	- `nterface`를 사용함으로써, `service`에 의존하는 class는 더 이상 `service`의 구현에 의존하지 않게 된다. 이것이 `service`를 독립적으로 사용할 수 있게 해준다.
	
[interface 를 service 에 사용해야 하는 경우]
- 여러 방식의 구현 
- 제어의 역전 / IoC 

인터페이스 타입에 어떤 구현 객체를 대입하는지에 따라 실행결과가 달라지도록 만드는 기술이므로 기존 구현 객체(ServiceImpl1)와 **비즈니스 로직이 다른 기능을 추가해야할 경우** 다른 구현 객체(ServiceImpl2)를 만들어 사용하면 된다. 따라서 유지보수 측면에서 매우 좋다.

AOP와 트랜잭션은 서비스 인터페이스에서 처리한다.  
스프링에서 AOP를 구현할 때 JDK의 기본 프록시를 사용하는데, 이 프록시는 인터페이스 기반으로 동작하기 때문에 Service인터페이스를 만들어 사용한다.

**AOP란** 기존에 OOP에서 바라보던 관점을 다르게 하여 부가기능적은 측면에서 보았을 때 공통된 요소를 추출하자는 것입니다.
- AOP : 인프라, 부가 기능의 모둘화
	- 공통 기능 재사용 기법
	- 부가적인 기능을 분리하여 Aspect 라는 모듈로 설계하고 개발 


![[Pasted image 20230320182922.png]]





[참고]
https://velog.io/@kshired/Spring-Java-Interface-AbstractClass%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EA%B3%BC-ServiceImpl-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0
https://velog.io/@hsw0194/Spring-Boot%EC%97%90%EC%84%9C-interface%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C

https://velog.io/@hsw0194/Spring-Boot%EC%97%90%EC%84%9C-interface%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C

https://jung-story.tistory.com/129

https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-vs-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0

https://velog.io/@suhongkim98/%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B5%AC%ED%98%84-%EC%8B%9C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-spring-AOP

https://tecoble.techcourse.co.kr/post/2022-11-07-transaction-aop-fact-and-misconception/

